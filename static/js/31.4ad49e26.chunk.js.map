{"version":3,"sources":["components/chartArea/chartArea.js"],"names":["ChartArea","state","chartWidth","dataSetsToggle","resizeObserver","helpers","noop","containerRef","React","createRef","tooltipRef","onHide","id","forceUpdate","onRevert","onToggle","updatedToggle","onResizeContainer","current","clientWidth","setState","getIsToggled","this","setResizeObserve","containerElement","ResizeObserver","window","observe","unobserve","addEventListener","removeEventListener","props","xAxisLabelIncrement","xAxisTickFormat","yAxisTickFormat","dataSets","xAxisProps","yAxisProps","xAxisDataSet","length","data","forEach","dataSet","xAxisLabelUseDataSet","xAxisTickValues","reduce","acc","index","concat","x","tickValue","xAxisLabel","tick","tickValues","tickIndex","indexOf","previousItem","nextItem","item","xAxisFixLabelOverlap","setChartTicks","updatedXAxisProps","fixLabelOverlap","updatedYAxisProps","dependentAxis","showGrid","tickFormat","isXAxisTicks","domain","Object","keys","generatedDomain","updatedChartDomain","dataSetMaxX","dataSetMaxY","filter","set","isStacked","dataSetMaxYStacked","value","y","floored","Math","pow","floor","log10","ceil","maxY","chartDomain","chartTooltip","tooltipDataSet","map","itemsByKey","color","stroke","fill","_cloneDeep","mockDatum","datum","tooltip","isValidElement","cloneElement","values","v","VictoryVoronoiCursorContainer","createContainer","parsedTooltipData","getTooltipData","getXCoordinate","width","tooltipWidth","xCoordinate","getYCoordinate","height","tooltipHeight","yCoordinate","FlyoutComponent","obj","containerBounds","getBoundingClientRect","tooltipBounds","htmlContent","t","find","applyParsedTooltipData","ref","style","display","xmlns","labelComponent","flyout","flyoutStyle","renderInPortal","cursorDimension","labels","voronoiPadding","mouseFollowTooltips","chartLegend","legendProps","chart","hide","revert","toggle","isToggled","stacked","charts","chartsStacked","updatedDataSet","isThreshold","dataColorStroke","strokeWidth","strokeDasharray","animate","interpolation","name","themeColor","themeVariant","generateId","thresholdChart","areaChart","push","padding","getChartTicks","getChartDomain","tooltipComponent","containerComponent","renderTooltip","undefined","chartProps","className","duration","renderChart","renderLegend","Component","defaultProps","bottom","left","right","top"],"mappings":"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","file":"static/js/31.4ad49e26.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { createContainer } from 'victory-create-container';\nimport {\n  Chart,\n  ChartAxis,\n  ChartStack,\n  ChartThreshold,\n  ChartThemeColor,\n  ChartArea as PfChartArea,\n  ChartCursorFlyout,\n  ChartCursorTooltip\n} from '@patternfly/react-charts';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { helpers } from '../../common';\n\n/**\n * FixMe: chart redraw flash related to custom tooltips use\n * Removing custom tooltips corrects redraw issues. As a temporary patch, caching at the selector alleviates\n * the symptoms.\n */\n/**\n * A wrapper for Patternfly and Victory charts/graphs.\n *\n * @augments React.Component\n * @fires onResizeContainer\n * @fires onHide\n * @fires onRevert\n * @fires onToggle\n */\nclass ChartArea extends React.Component {\n  state = { chartWidth: 0 };\n\n  dataSetsToggle = {};\n\n  resizeObserver = helpers.noop;\n\n  containerRef = React.createRef();\n\n  tooltipRef = React.createRef();\n\n  componentDidMount() {\n    this.setResizeObserve();\n  }\n\n  componentWillUnmount() {\n    this.resizeObserver();\n  }\n\n  /**\n   * Consumer exposed, hides chart layer.\n   *\n   * @event onHide\n   * @param {string} id\n   */\n  onHide = id => {\n    this.dataSetsToggle = { ...this.dataSetsToggle, [id]: true };\n    this.forceUpdate();\n  };\n\n  /**\n   * Consumer exposed, turns all chart layers back on.\n   *\n   * @event onRevert\n   */\n  onRevert = () => {\n    this.dataSetsToggle = {};\n    this.forceUpdate();\n  };\n\n  /**\n   * Consumer exposed, turns chart layer on/off.\n   *\n   * @event onToggle\n   * @param {string} id\n   * @returns {boolean}\n   */\n  onToggle = id => {\n    const updatedToggle = !this.dataSetsToggle[id];\n    this.dataSetsToggle = { ...this.dataSetsToggle, [id]: updatedToggle };\n    this.forceUpdate();\n\n    return updatedToggle;\n  };\n\n  /**\n   * On resize adjust graph display.\n   *\n   * @event onResizeContainer\n   */\n  onResizeContainer = () => {\n    const { chartWidth } = this.state;\n    const { clientWidth = 0 } = this.containerRef.current || {};\n\n    if (clientWidth !== chartWidth) {\n      this.setState({ chartWidth: clientWidth });\n    }\n  };\n\n  /**\n   * Consumer exposed, determine if chart layer on/off.\n   * Note: Using \"setState\" as related to this exposed check gives the appearance of a race condition.\n   * Using a class property with forceUpdate to bypass.\n   *\n   * @param {string} id\n   * @returns {boolean}\n   */\n  getIsToggled = id => this.dataSetsToggle[id] || false;\n\n  /**\n   * Set ResizeObserver for scenarios where the window.resize event doesn't fire.\n   */\n  setResizeObserve() {\n    const containerElement = this.containerRef.current;\n    const { ResizeObserver } = window;\n\n    if (containerElement && ResizeObserver) {\n      const resizeObserver = new ResizeObserver(this.onResizeContainer);\n      resizeObserver.observe(containerElement);\n      this.resizeObserver = () => resizeObserver.unobserve(containerElement);\n    } else {\n      this.onResizeContainer();\n      window.addEventListener('resize', this.onResizeContainer);\n      this.resizeObserver = () => window.removeEventListener('resize', this.onResizeContainer);\n    }\n  }\n\n  /**\n   * Apply props, set x and y axis chart increments/ticks formatting.\n   *\n   * @returns {object}\n   */\n  setChartTicks() {\n    const { xAxisLabelIncrement, xAxisTickFormat, yAxisTickFormat, dataSets } = this.props;\n    const xAxisProps = {};\n    const yAxisProps = {};\n    let xAxisDataSet = (dataSets.length && dataSets[0].data) || [];\n\n    dataSets.forEach(dataSet => {\n      if (dataSet.xAxisLabelUseDataSet) {\n        xAxisDataSet = dataSet.data;\n      }\n    });\n\n    xAxisProps.xAxisTickValues = xAxisDataSet.reduce(\n      (acc, current, index) => (index % xAxisLabelIncrement === 0 ? acc.concat(current.x) : acc),\n      []\n    );\n\n    xAxisProps.xAxisTickFormat = tickValue =>\n      (xAxisDataSet[tickValue] && xAxisDataSet[tickValue].xAxisLabel) || tickValue;\n\n    if (typeof xAxisTickFormat === 'function') {\n      xAxisProps.xAxisTickFormat = tick => {\n        const tickValues = xAxisProps.xAxisTickValues;\n        const tickIndex = tickValues.indexOf(tick);\n        const previousItem = { ...(xAxisDataSet[tickValues[tickIndex - 1]] || {}) };\n        const nextItem = { ...(xAxisDataSet[tickValues[tickIndex + 1]] || {}) };\n        const item = { ...(xAxisDataSet[tick] || {}) };\n\n        return xAxisTickFormat({ tick, previousItem, item, nextItem });\n      };\n    }\n\n    if (typeof yAxisTickFormat === 'function') {\n      yAxisProps.yAxisTickFormat = tick => yAxisTickFormat({ tick });\n    }\n\n    return {\n      ...xAxisProps,\n      ...yAxisProps\n    };\n  }\n\n  /**\n   * Return x and y axis increments/ticks.\n   *\n   * @returns {object}\n   */\n  getChartTicks() {\n    const { xAxisFixLabelOverlap } = this.props;\n\n    const { xAxisTickValues, xAxisTickFormat, yAxisTickFormat } = this.setChartTicks();\n    const updatedXAxisProps = {\n      fixLabelOverlap: xAxisFixLabelOverlap\n    };\n    const updatedYAxisProps = {\n      dependentAxis: true,\n      showGrid: true\n    };\n\n    if (xAxisTickValues) {\n      updatedXAxisProps.tickValues = xAxisTickValues;\n    }\n\n    if (xAxisTickFormat) {\n      updatedXAxisProps.tickFormat = xAxisTickFormat;\n    }\n\n    if (yAxisTickFormat) {\n      updatedYAxisProps.tickFormat = yAxisTickFormat;\n    }\n\n    return {\n      isXAxisTicks: !!xAxisTickValues,\n      xAxisProps: updatedXAxisProps,\n      yAxisProps: updatedYAxisProps\n    };\n  }\n\n  /**\n   * Calculate and return the x and y domain range.\n   *\n   * @param {boolean} isXAxisTicks\n   * @returns {object}\n   */\n  getChartDomain({ isXAxisTicks }) {\n    const { dataSetsToggle } = this;\n    const { domain, dataSets } = this.props;\n\n    if (Object.keys(domain).length) {\n      return domain;\n    }\n\n    const generatedDomain = {};\n    const updatedChartDomain = {};\n    let dataSetMaxX = 0;\n    let dataSetMaxY = 0;\n\n    const stackedSets = dataSets.filter(set => set.isStacked === true);\n\n    stackedSets.forEach(dataSet => {\n      if (!dataSetsToggle[dataSet.id] && dataSet.data) {\n        let dataSetMaxYStacked = 0;\n\n        dataSet.data.forEach((value, index) => {\n          dataSetMaxYStacked = value && value.y > dataSetMaxYStacked ? value.y : dataSetMaxYStacked;\n\n          if (index === dataSet.data.length - 1) {\n            dataSetMaxY += dataSetMaxYStacked;\n          }\n        });\n      }\n    });\n\n    dataSets.forEach(dataSet => {\n      if (!dataSetsToggle[dataSet.id] && dataSet.data) {\n        dataSetMaxX = dataSet.data.length > dataSetMaxX ? dataSet.data.length : dataSetMaxX;\n\n        dataSet.data.forEach(value => {\n          dataSetMaxY = value && value.y > dataSetMaxY ? value.y : dataSetMaxY;\n        });\n      }\n    });\n\n    if (!isXAxisTicks) {\n      generatedDomain.x = [0, dataSetMaxX || 10];\n    }\n\n    const floored = Math.pow(10, Math.floor(Math.log10((dataSetMaxY > 10 && dataSetMaxY) || 10)));\n    generatedDomain.y = [0, Math.ceil((dataSetMaxY + 1) / floored) * floored];\n\n    if (Object.keys(generatedDomain).length) {\n      updatedChartDomain.domain = generatedDomain;\n    }\n\n    return {\n      maxY: dataSetMaxY,\n      chartDomain: { ...updatedChartDomain }\n    };\n  }\n\n  /**\n   * Apply data set to custom tooltips.\n   *\n   * @returns {Array}\n   */\n  getTooltipData() {\n    const { dataSetsToggle } = this;\n    const { dataSets, chartTooltip } = this.props;\n    let tooltipDataSet = [];\n\n    if (chartTooltip && dataSets && dataSets[0] && dataSets[0].data) {\n      tooltipDataSet = dataSets[0].data.map((dataSet, index) => {\n        const itemsByKey = {};\n\n        dataSets.forEach(data => {\n          if (!dataSetsToggle[data.id] && data.data && data.data[index]) {\n            itemsByKey[data.id] = {\n              color: data.stroke || data.fill || data.color || '',\n              data: _cloneDeep(data.data[index])\n            };\n          }\n        });\n\n        const mockDatum = {\n          datum: { x: dataSet.x, y: dataSet.y, index, itemsByKey, dataSets: _cloneDeep(dataSets) }\n        };\n\n        return {\n          x: dataSet.x,\n          y: null,\n          itemsByKey,\n          tooltip:\n            (React.isValidElement(chartTooltip) && React.cloneElement(chartTooltip, { ...mockDatum })) ||\n            chartTooltip({ ...mockDatum })\n        };\n      });\n    }\n\n    return tooltipDataSet;\n  }\n\n  /**\n   * Return a chart/graph tooltip Victory container component to allow custom HTML tooltips.\n   *\n   * @returns {Node}\n   */\n  renderTooltip() {\n    const { dataSetsToggle } = this;\n    const { chartTooltip, dataSets } = this.props;\n\n    if (!chartTooltip || Object.values(dataSetsToggle).filter(v => v === true).length === dataSets.length) {\n      return null;\n    }\n\n    const VictoryVoronoiCursorContainer = createContainer('voronoi', 'cursor');\n    const parsedTooltipData = this.getTooltipData();\n\n    const applyParsedTooltipData = ({ datum }) => {\n      const t = parsedTooltipData.find(v => v.x === datum.x) || {};\n      return t?.tooltip || '';\n    };\n\n    const getXCoordinate = (x, width, tooltipWidth) => {\n      let xCoordinate = x + 10;\n\n      if (x > width / 2) {\n        xCoordinate = x - 10 - tooltipWidth / 2;\n      }\n\n      return xCoordinate;\n    };\n\n    const getYCoordinate = (y, height, tooltipHeight) => {\n      let yCoordinate = y + 10;\n\n      if (y > height / 2) {\n        yCoordinate = y - 10 - tooltipHeight;\n      }\n\n      return yCoordinate;\n    };\n\n    const FlyoutComponent = obj => {\n      const containerRef = this.containerRef.current;\n      const tooltipRef = this.tooltipRef.current;\n      const containerBounds = (containerRef && containerRef.getBoundingClientRect()) || { width: 0, height: 0 };\n      const tooltipBounds = (tooltipRef && tooltipRef.getBoundingClientRect()) || { width: 0, height: 0 };\n      const htmlContent = applyParsedTooltipData({ ...obj });\n\n      if (htmlContent) {\n        return (\n          <g>\n            <foreignObject\n              x={getXCoordinate(obj.x, containerBounds.width, tooltipBounds.width)}\n              y={getYCoordinate(obj.y, containerBounds.height, tooltipBounds.height)}\n              width=\"100%\"\n              height=\"100%\"\n            >\n              <div ref={this.tooltipRef} style={{ display: 'inline-block' }} xmlns=\"http://www.w3.org/1999/xhtml\">\n                {htmlContent}\n              </div>\n            </foreignObject>\n          </g>\n        );\n      }\n\n      return <g />;\n    };\n\n    const labelComponent = (\n      <ChartCursorTooltip\n        flyout={<ChartCursorFlyout />}\n        flyoutStyle={{ fill: 'transparent' }}\n        labelComponent={<FlyoutComponent />}\n        renderInPortal\n      />\n    );\n\n    return (\n      <VictoryVoronoiCursorContainer\n        cursorDimension=\"x\"\n        labels={obj => obj}\n        labelComponent={labelComponent}\n        voronoiPadding={50}\n        mouseFollowTooltips\n      />\n    );\n  }\n\n  /**\n   * Return a custom chart/graph legend component.\n   *\n   * @returns {Node}\n   */\n  renderLegend() {\n    const { chartLegend, dataSets } = this.props;\n\n    if (!chartLegend) {\n      return null;\n    }\n\n    const legendProps = {\n      datum: { dataSets: _cloneDeep(dataSets) },\n      chart: {\n        hide: this.onHide,\n        revert: this.onRevert,\n        toggle: this.onToggle,\n        isToggled: this.getIsToggled\n      }\n    };\n\n    return (\n      (React.isValidElement(chartLegend) && React.cloneElement(chartLegend, { ...legendProps })) ||\n      chartLegend({ ...legendProps })\n    );\n  }\n\n  /**\n   * Return a list/array of both stacked and non-stacked charts/graphs.\n   *\n   * @param {boolean} stacked\n   * @returns {Array}\n   */\n  renderChart({ stacked = false }) {\n    const { dataSetsToggle } = this;\n    const { dataSets } = this.props;\n    const charts = [];\n    const chartsStacked = [];\n\n    const thresholdChart = (dataSet, index) => {\n      const dataColorStroke = { data: {} };\n\n      if (dataSet.fill) {\n        dataColorStroke.data.fill = dataSet.fill;\n      }\n\n      if (dataSet.stroke) {\n        dataColorStroke.data.stroke = dataSet.stroke;\n      }\n\n      if (dataSet.strokeWidth) {\n        dataColorStroke.data.strokeWidth = dataSet.strokeWidth;\n      }\n\n      if (dataSet.strokeDasharray) {\n        dataColorStroke.data.strokeDasharray = dataSet.strokeDasharray;\n      }\n\n      return (\n        <ChartThreshold\n          animate={dataSet.animate || false}\n          interpolation={dataSet.interpolation || 'step'}\n          key={helpers.generateId()}\n          name={`chartArea-${index}-threshold`}\n          data={dataSet.data}\n          style={{ ...(dataSet.style || {}), ...dataColorStroke }}\n          // FixMe: PFCharts inconsistent implementation around themeColor and style, see ChartArea. Appears enforced, see PFCharts. Leads to multiple checks and implementations.\n          themeColor={dataSet.themeColor}\n          themeVariant={dataSet.themeVariant}\n        />\n      );\n    };\n\n    const areaChart = (dataSet, index) => {\n      const dataColorStroke = { data: {} };\n\n      if (dataSet.fill) {\n        dataColorStroke.data.fill = dataSet.fill;\n      }\n\n      if (dataSet.stroke) {\n        dataColorStroke.data.stroke = dataSet.stroke;\n      }\n\n      if (dataSet.strokeWidth) {\n        dataColorStroke.data.strokeWidth = dataSet.strokeWidth;\n      }\n\n      return (\n        <PfChartArea\n          animate={dataSet.animate || false}\n          interpolation={dataSet.interpolation || 'monotoneX'}\n          key={helpers.generateId()}\n          name={`chartArea-${index}-area`}\n          data={dataSet.data}\n          style={{ ...(dataSet.style || {}), ...dataColorStroke }}\n          // FixMe: PFCharts inconsistent implementation around themeColor and style, see ChartThreshold themeColor and style\n          themeColor={dataSet.themeColor}\n          themeVariant={dataSet.themeVariant}\n        />\n      );\n    };\n\n    dataSets.forEach((dataSet, index) => {\n      if (!dataSetsToggle[dataSet.id] && dataSet.data && dataSet.data.length) {\n        const updatedDataSet = (dataSet.isThreshold && thresholdChart(dataSet, index)) || areaChart(dataSet, index);\n\n        if (dataSet.isStacked) {\n          chartsStacked.push(updatedDataSet);\n        } else {\n          charts.push(updatedDataSet);\n        }\n      }\n    });\n\n    return (stacked && chartsStacked) || charts;\n  }\n\n  /**\n   * Render a chart/graph.\n   *\n   * @returns {Node}\n   */\n  render() {\n    const { chartWidth } = this.state;\n    const { chartLegend, padding, themeColor } = this.props;\n\n    const { isXAxisTicks, xAxisProps, yAxisProps } = this.getChartTicks();\n    const { chartDomain, maxY } = this.getChartDomain({ isXAxisTicks });\n    const tooltipComponent = { containerComponent: (maxY >= 0 && this.renderTooltip()) || undefined };\n    const chartProps = { padding, ...chartDomain, ...tooltipComponent };\n\n    return (\n      <div\n        id=\"curiosity-chartarea\"\n        className=\"uxui-curiosity__modal uxui-curiosity__modal--loading\"\n        ref={this.containerRef}\n      >\n        <Chart animate={{ duration: 0 }} width={chartWidth} themeColor={themeColor} {...chartProps}>\n          <ChartAxis {...xAxisProps} animate={false} />\n          <ChartAxis {...yAxisProps} animate={false} />\n          {this.renderChart({})}\n          <ChartStack>{this.renderChart({ stacked: true })}</ChartStack>\n        </Chart>\n        {chartLegend && <div className=\"curiosity-chartarea-description victory-legend\">{this.renderLegend()}</div>}\n      </div>\n    );\n  }\n}\n\n/**\n * Prop types.\n *\n * @type {{chartLegend: Node|Function, chartTooltip: Node|Function, padding, xAxisTickFormat: Function,\n *     themeColor: string, yAxisTickFormat: Function, domain: object|Array, dataSets: object,\n *     xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number, height: number}}\n */\nChartArea.propTypes = {\n  chartLegend: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  chartTooltip: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  dataSets: PropTypes.arrayOf(\n    PropTypes.shape({\n      data: PropTypes.arrayOf(\n        PropTypes.shape({\n          x: PropTypes.number.isRequired,\n          y: PropTypes.number,\n          xAxisLabel: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        })\n      ),\n      animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n      fill: PropTypes.string,\n      stroke: PropTypes.string,\n      strokeWidth: PropTypes.number,\n      strokeDasharray: PropTypes.string,\n      themeColor: PropTypes.string,\n      themeVariant: PropTypes.string,\n      id: PropTypes.string.isRequired,\n      interpolation: PropTypes.string,\n      legendLabel: PropTypes.string,\n      legendSymbolType: PropTypes.string,\n      style: PropTypes.object,\n      isStacked: PropTypes.bool,\n      isThreshold: PropTypes.bool,\n      xAxisLabelUseDataSet: PropTypes.bool\n    })\n  ),\n  domain: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n  height: PropTypes.number,\n  padding: PropTypes.shape({\n    bottom: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    top: PropTypes.number\n  }),\n  themeColor: PropTypes.oneOf(Object.values(ChartThemeColor)),\n  xAxisFixLabelOverlap: PropTypes.bool,\n  xAxisLabelIncrement: PropTypes.number,\n  xAxisTickFormat: PropTypes.func,\n  yAxisTickFormat: PropTypes.func\n};\n\n/**\n * Default props.\n *\n * @type {{chartLegend: null, chartTooltip: null, padding: {top: number, left: number, bottom: number,\n *     right: number}, xAxisTickFormat: null, themeColor: string, yAxisTickFormat: null, domain: object,\n *     dataSets: Array, xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number, height: number}}\n */\nChartArea.defaultProps = {\n  chartLegend: null,\n  chartTooltip: null,\n  domain: {},\n  dataSets: [],\n  height: 275,\n  padding: {\n    bottom: 75,\n    left: 50,\n    right: 50,\n    top: 50\n  },\n  themeColor: 'blue',\n  xAxisFixLabelOverlap: false,\n  xAxisLabelIncrement: 1,\n  xAxisTickFormat: null,\n  yAxisTickFormat: null\n};\n\nexport { ChartArea as default, ChartArea };\n"],"sourceRoot":""}