{"version":3,"sources":["components/chart/chartContext.js","components/chart/chartTooltip.js","components/chart/chartElements.js","components/chart/chartLegend.js","components/chart/chartHelpers.js","hooks/useWindow.js","components/chart/chart.js"],"names":["DEFAULT_CONTEXT","chartContainerRef","helpers","noop","chartSettings","chartTooltipRef","dataSetsToggle","ChartContext","React","createContext","useChartContext","useContext","useToggleData","useAliasChartContext","contextDataSetsToggle","setDataSetsToggle","onHide","useCallback","id","prevState","onRevert","onToggle","updatedToggle","getIsToggled","context","chartTooltip","minChartWidth","getXCoordinate","x","width","tooltipWidth","padding","minWidth","getYCoordinate","y","height","tooltipHeight","tailPosition","datum","tooltipDataSetLookUp","containerRef","tooltipRef","content","tooltip","containerPaddingBottom","bottom","containerBounds","current","querySelector","getBoundingClientRect","tooltipBounds","updatedClassName","className","ref","style","display","xmlns","ChartElements","chartElements","stackedChartElements","chartTypeDefaults","chartDomain","chartElementsProps","chartWidth","hasData","themeColor","xAxisProps","yAxisProps","containerComponent","yAxis","VictoryVoronoiCursorContainer","createContainer","TooltipLabelComponent","cursorDimension","voronoiDimension","labels","obj","labelComponent","dx","dy","centerOffset","flyoutStyle","fill","stroke","voronoiPadding","mouseFollowTooltips","Array","isArray","map","axisProps","animate","orientation","setChartElement","chartType","props","area","Component","component","defaultProps","elements","stackedElements","duration","ChartArea","onLoad","interpolation","line","ChartLine","threshold","ChartThreshold","ChartLegend","chartLegend","dataSets","legendProps","_cloneDeep","chart","hide","revert","toggle","isToggled","isValidElement","cloneElement","generateMaxXY","individualDataSetsMaxY","combinedDataSetMaxX","combinedDataSetsMaxY","filter","isStacked","forEach","data","Math","max","value","dataSetMaxY","length","maxX","maxY","individualMaxY","generateDomains","updatedChartDomain","generatedDomain","Object","values","floored","pow","floor","log10","ceil","keys","domain","generateElementsProps","xValueFormat","yValueFormat","elementsById","stackedElementsById","dataSet","strokeDasharray","strokeWidth","dataColorStroke","chartElementProps","key","name","themeVariant","undefined","isMultiAxis","updatedProps","push","generateTooltipData","index","itemsByKey","color","mockDatum","generateXAxisProps","xAxisLabelIncrement","xAxisPropDefaults","xAxisTickFormat","tickValues","reduce","acc","concat","tickFormat","tick","xAxisLabel","tickIndex","indexOf","previousItem","nextItem","item","generateYAxisProps","yAxisPropDefaults","yAxisTickFormat","updatedAxisProps","axis","tickLabels","updatedMaxY","generateAxisProps","xAxisDataSet","xAxisFixLabelOverlap","fixLabelOverlap","dependentAxis","showGrid","yAxisDataSets","yAxisUseDataSet","xAxisUseDataSet","slice","chartHelpers","useResizeObserver","target","useState","dimensions","setDimensions","useEffect","isElementResize","window","ResizeObserver","element","removeObserver","handler","clientHeight","clientWidth","innerHeight","innerWidth","resizeObserver","observe","unobserve","addEventListener","removeEventListener","Chart","setContext","useRef","toggledDataSets","isMultiYAxis","updateChartSettings","updatedSettings","Provider","Fragment","left","right","top"],"mappings":"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","file":"static/js/23.aa044cf1.chunk.js","sourcesContent":["import React, { useCallback, useContext } from 'react';\nimport { helpers } from '../../common';\n\n/**\n * Chart context.\n *\n * @type {React.Context<{}>}\n */\nconst DEFAULT_CONTEXT = [\n  { chartContainerRef: helpers.noop, chartSettings: {}, chartTooltipRef: helpers.noop, dataSetsToggle: [] },\n  helpers.noop\n];\n\nconst ChartContext = React.createContext(DEFAULT_CONTEXT);\n\n/**\n * Get an updated chart context.\n *\n * @returns {React.Context<{}>}\n */\nconst useChartContext = () => useContext(ChartContext);\n\n/**\n * ToDo: reevaluate this alternative pattern of passing hooks as options, helps testing\n */\n/**\n * Track, show, and hide chart data layers.\n *\n * @param {object} hooks\n * @param {Function} hooks.useChartContext\n * @returns {{onRevert: Function, onToggle: Function, getIsToggled: Function, dataSetsToggle: object,\n *     onHide: Function}}\n */\nconst useToggleData = ({ useChartContext: useAliasChartContext = useChartContext } = {}) => {\n  const { dataSetsToggle: contextDataSetsToggle = [] } = useAliasChartContext();\n  const [dataSetsToggle, setDataSetsToggle] = contextDataSetsToggle;\n\n  /**\n   * Hide a graph layer.\n   *\n   * @type {(function(*): void)|*}\n   */\n  const onHide = useCallback(\n    id => {\n      setDataSetsToggle(prevState => ({ ...prevState, [id]: true }));\n    },\n    [setDataSetsToggle]\n  );\n\n  // ToDo: re-evaluate useCallback here.\n  /**\n   * Reset graph layers.\n   *\n   * @type {(function(): void)|*}\n   */\n  const onRevert = useCallback(() => {\n    setDataSetsToggle(() => ({}));\n  }, [setDataSetsToggle]);\n\n  /**\n   * Hide/show graph layers.\n   *\n   * @type {function(*): boolean}\n   */\n  const onToggle = useCallback(\n    id => {\n      const updatedToggle = !dataSetsToggle?.[id];\n      setDataSetsToggle(prevState => ({ ...prevState, [id]: updatedToggle }));\n      return updatedToggle;\n    },\n    [dataSetsToggle, setDataSetsToggle]\n  );\n\n  // ToDo: review return undefined if doesn't exist\n  /**\n   * Graph layer status.\n   *\n   * @type {function(*): boolean}\n   */\n  const getIsToggled = useCallback(id => dataSetsToggle?.[id] || false, [dataSetsToggle]);\n\n  return {\n    ...{ dataSetsToggle },\n    onHide,\n    onRevert,\n    onToggle,\n    getIsToggled\n  };\n};\n\nconst context = {\n  ChartContext,\n  DEFAULT_CONTEXT,\n  useChartContext,\n  useToggleData\n};\n\nexport { context as default, context, ChartContext, DEFAULT_CONTEXT, useChartContext, useToggleData };\n","import React from 'react';\nimport { helpers } from '../../common';\n\n/**\n * Note: Victory Charts components require a form of extended \"something\" applied by the consuming component.\n * This leads to odd implementations, like returning a function component.\n */\n/**\n * Return a compatible Victory tooltip component.\n *\n * @param {object} params\n * @param {object} params.chartSettings\n * @param {Function} params.chartContainerRef\n * @param {Function} params.chartTooltipRef\n * @param {number} params.minChartWidth\n * @returns {Function}\n */\nconst chartTooltip = ({\n  chartSettings = {},\n  chartContainerRef = helpers.noop,\n  chartTooltipRef = helpers.noop,\n  minChartWidth = 500\n} = {}) => {\n  // ToDo: evaluate using \"width\" in place of \"minWidth\" for scenarios where the graph size is smaller\n  /**\n   * Return a tooltip x coordinate.\n   *\n   * @param {object} params\n   * @param {number} params.x\n   * @param {number} params.width\n   * @param {number} params.tooltipWidth\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const getXCoordinate = ({ x, width, tooltipWidth, padding = 0, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth && x > tooltipWidth / 2 + padding && x < minWidth - tooltipWidth + padding) {\n      return x + padding - tooltipWidth / 2;\n    }\n\n    return x > width / 2 ? x - tooltipWidth + padding : x + padding;\n  };\n\n  /**\n   * Return a tooltip y coordinate.\n   *\n   * @param {object} params\n   * @param {number} params.y\n   * @param {number} params.height\n   * @param {number} params.tooltipHeight\n   * @param {number} params.width\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const getYCoordinate = ({ y, height, tooltipHeight, width, padding = 15, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth) {\n      return y > height / 2 ? y - tooltipHeight - padding : y + padding;\n    }\n\n    return height * 0.25;\n  };\n\n  // ToDo: evaluate using \"width\" in place of \"minWidth\" for scenarios where the graph size is smaller\n  /**\n   * Return a tooltip tail position CSS class.\n   *\n   * @param {object} params\n   * @param {number} params.x\n   * @param {number} params.width\n   * @param {number} params.tooltipWidth\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const tailPosition = ({ x, width, tooltipWidth, padding = 0, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth && x > tooltipWidth / 2 + padding && x < minWidth - tooltipWidth + padding) {\n      return 'middle';\n    }\n\n    return x > width / 2 ? 'right' : 'left';\n  };\n\n  return ({ x, y, datum = {} }) => { // eslint-disable-line\n    const { padding = {}, tooltipDataSetLookUp = {} } = chartSettings;\n\n    const containerRef = chartContainerRef();\n    const tooltipRef = chartTooltipRef();\n    const content = tooltipDataSetLookUp?.[datum.x]?.tooltip || '';\n    const containerPaddingBottom = padding.bottom ?? 0;\n    const containerBounds = containerRef?.current?.querySelector('svg')?.getBoundingClientRect() || {\n      width: 0,\n      height: 0\n    };\n    const tooltipBounds = tooltipRef?.current?.getBoundingClientRect() || { width: 0, height: 0 };\n\n    if (content) {\n      const updatedClassName = `${(tooltipBounds.height <= 0 && 'fadein') || ''}`;\n\n      return (\n        <g>\n          <foreignObject\n            x={getXCoordinate({ x, width: containerBounds.width, tooltipWidth: tooltipBounds.width })}\n            y={getYCoordinate({\n              y,\n              height: containerBounds.height,\n              tooltipHeight: tooltipBounds.height,\n              width: containerBounds.width\n            })}\n            width=\"100%\"\n            height=\"100%\"\n          >\n            <div\n              className={`curiosity-chartarea__tooltip-container ${updatedClassName}`}\n              ref={tooltipRef}\n              style={{ display: (y > containerBounds.height - containerPaddingBottom && 'none') || 'inline-block' }}\n              xmlns=\"http://www.w3.org/1999/xhtml\"\n            >\n              <div\n                className={`curiosity-chartarea__tooltip curiosity-chartarea__tooltip-${tailPosition({\n                  x,\n                  y,\n                  width: containerBounds.width,\n                  tooltipWidth: tooltipBounds.width\n                })}`}\n              >\n                {content}\n              </div>\n            </div>\n          </foreignObject>\n        </g>\n      );\n    }\n\n    return <g />;\n  };\n};\n\nexport { chartTooltip as default, chartTooltip };\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { VictoryStack as ChartStack, VictoryTooltip as ChartCursorTooltip } from 'victory';\nimport { createContainer } from 'victory-create-container';\nimport { Chart, ChartArea, ChartAxis, ChartContainer, ChartLine, ChartThreshold } from '@patternfly/react-charts';\nimport { useChartContext } from './chartContext';\nimport { chartTooltip } from './chartTooltip';\n\n/**\n * Generate a compatible Victory chart element/facet component.\n *\n * @param {object} props\n * @param {object} props.chartTypeDefaults\n * @returns {Node}\n */\nconst ChartElements = ({ chartTypeDefaults }) => {\n  const { chartSettings = {}, chartContainerRef, chartTooltipRef } = useChartContext();\n  const {\n    chartDomain,\n    chartElementsProps,\n    chartWidth,\n    hasData,\n    padding,\n    themeColor,\n    xAxisProps,\n    yAxisProps\n  } = chartSettings;\n\n  let containerComponent = <ChartContainer />;\n  let yAxis = null;\n  let chartElements = [];\n  let stackedChartElements = [];\n\n  if (hasData) {\n    /**\n     * Note: both cursor and voronoiDimension attrs required if the need is to have...\n     * the tooltip populate consistently without being \"near\" a chart element y axis point\n     */\n    const VictoryVoronoiCursorContainer = createContainer('voronoi', 'cursor');\n    const TooltipLabelComponent = chartTooltip({ chartSettings, chartContainerRef, chartTooltipRef });\n\n    containerComponent = (\n      <VictoryVoronoiCursorContainer\n        cursorDimension=\"x\"\n        voronoiDimension=\"x\"\n        labels={obj => obj}\n        labelComponent={\n          <ChartCursorTooltip\n            dx={0}\n            dy={0}\n            centerOffset={{ x: 0, y: 0 }}\n            flyoutStyle={{ fill: 'transparent', stroke: 'transparent' }}\n            labelComponent={<TooltipLabelComponent />}\n          />\n        }\n        voronoiPadding={50}\n        mouseFollowTooltips\n      />\n    );\n  }\n\n  if (Array.isArray(yAxisProps)) {\n    yAxis = yAxisProps.map(axisProps => (\n      <ChartAxis key={`yaxis-${axisProps.orientation}`} {...axisProps} animate={false} />\n    ));\n  }\n\n  const setChartElement = ({ chartType, props }) => {\n    const { component: Component, ...defaultProps } = chartTypeDefaults[chartType] || chartTypeDefaults.area;\n    return <Component {...{ ...defaultProps, ...props }} />;\n  };\n\n  chartElements = chartElementsProps?.elements.map(setChartElement);\n  stackedChartElements = chartElementsProps?.stackedElements.map(setChartElement);\n\n  return (\n    <Chart\n      animate={{ duration: 0 }}\n      width={chartWidth}\n      themeColor={themeColor}\n      {...{ padding, containerComponent, ...chartDomain }}\n    >\n      <ChartAxis {...xAxisProps} animate={false} />\n      {yAxis}\n      {chartElements}\n      <ChartStack>{stackedChartElements}</ChartStack>\n    </Chart>\n  );\n};\n\nChartElements.propTypes = {\n  chartTypeDefaults: PropTypes.objectOf(\n    PropTypes.shape({\n      component: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n      animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n      interpolation: PropTypes.oneOf(['monotoneX', 'step'])\n    })\n  )\n};\n\nChartElements.defaultProps = {\n  chartTypeDefaults: {\n    area: {\n      component: ChartArea,\n      animate: {\n        duration: 250,\n        onLoad: { duration: 250 }\n      },\n      interpolation: 'monotoneX'\n    },\n    line: {\n      component: ChartLine,\n      animate: {\n        duration: 250,\n        onLoad: { duration: 250 }\n      },\n      interpolation: 'monotoneX'\n    },\n    threshold: {\n      component: ChartThreshold,\n      animate: {\n        duration: 100,\n        onLoad: { duration: 100 }\n      },\n      interpolation: 'step'\n    }\n  }\n};\n\nexport { ChartElements as default, ChartElements };\n","import React from 'react';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { useChartContext, useToggleData } from './chartContext';\n\n/**\n * Wrapper for rendering an HTML based legend.\n *\n * @returns {Node}\n */\nconst ChartLegend = () => {\n  const { getIsToggled, onHide, onRevert, onToggle } = useToggleData();\n  const { chartSettings = {} } = useChartContext();\n  const { chartLegend, dataSets } = chartSettings;\n\n  if (!chartLegend) {\n    return null;\n  }\n\n  const legendProps = {\n    datum: { dataSets: _cloneDeep(dataSets) },\n    chart: {\n      hide: onHide,\n      revert: onRevert,\n      toggle: onToggle,\n      isToggled: getIsToggled\n    }\n  };\n\n  return (\n    <div className=\"curiosity-chartarea__legend\">\n      {(React.isValidElement(chartLegend) && React.cloneElement(chartLegend, { ...legendProps })) ||\n        chartLegend({ ...legendProps })}\n    </div>\n  );\n};\n\n/**\n * Prop types.\n */\nChartLegend.propTypes = {};\n\n/**\n * Default props.\n */\nChartLegend.defaultProps = {};\n\nexport { ChartLegend as default, ChartLegend };\n","import React from 'react';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { helpers } from '../../common';\n\n/**\n * Generate max X and Y values from datasets.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @returns {{individualMaxY: object, maxY: number, maxX: number}}\n */\nconst generateMaxXY = ({ dataSets = [] } = {}) => {\n  const individualDataSetsMaxY = {};\n  let combinedDataSetMaxX = 0;\n  let combinedDataSetsMaxY = 0;\n\n  dataSets\n    .filter(({ isStacked }) => isStacked === true)\n    .forEach(({ data }) => {\n      if (Array.isArray(data)) {\n        combinedDataSetsMaxY += Math.max(...data.map(value => value?.y ?? 0));\n      }\n    });\n\n  dataSets.forEach(({ id, data }) => {\n    let dataSetMaxY = 0;\n\n    if (Array.isArray(data)) {\n      combinedDataSetMaxX = data.length > combinedDataSetMaxX ? data.length : combinedDataSetMaxX;\n\n      dataSetMaxY = Math.max(...data.map(value => value?.y ?? 0));\n      combinedDataSetsMaxY = dataSetMaxY > combinedDataSetsMaxY ? dataSetMaxY : combinedDataSetsMaxY;\n    }\n\n    if (id) {\n      individualDataSetsMaxY[id] = dataSetMaxY;\n    }\n  });\n\n  return {\n    maxX: combinedDataSetMaxX,\n    maxY: combinedDataSetsMaxY,\n    individualMaxY: individualDataSetsMaxY\n  };\n};\n\n/**\n * Generate Y axis domain ranges from dataSets, ignore X axis.\n *\n * @param {object} params\n * @param {number|object} params.maxY\n * @returns {{ domain: { y: Array } }}\n */\nconst generateDomains = ({ maxY } = {}) => {\n  const updatedChartDomain = {};\n  const generatedDomain = {};\n\n  if (Object.values(maxY).length) {\n    generatedDomain.y = [0, 1.25];\n  } else {\n    const floored = Math.pow(10, Math.floor(Math.log10(maxY || 10)));\n    generatedDomain.y = [0, Math.ceil((maxY + 1) / floored) * floored];\n  }\n\n  if (Object.keys(generatedDomain).length) {\n    updatedChartDomain.domain = generatedDomain;\n  }\n\n  return {\n    ...updatedChartDomain\n  };\n};\n\n/**\n * Generate chart element props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {Function} params.xValueFormat\n * @param {Function} params.yValueFormat\n * @returns {{elementsById: object, stackedElements: Array, stackedElementsById: object, elements: Array}}\n */\nconst generateElementsProps = ({ dataSets = [], maxX, maxY, xValueFormat, yValueFormat }) => {\n  const elements = [];\n  const stackedElements = [];\n  const elementsById = {};\n  const stackedElementsById = {};\n\n  dataSets.forEach(dataSet => {\n    const {\n      animate,\n      chartType,\n      data,\n      fill,\n      id,\n      isStacked,\n      interpolation,\n      stroke,\n      strokeDasharray,\n      strokeWidth\n    } = dataSet;\n\n    if (data?.length) {\n      const dataColorStroke = {\n        data: {}\n      };\n\n      if (fill && chartType !== 'line' && chartType !== 'threshold') {\n        dataColorStroke.data.fill = fill;\n      }\n\n      if (stroke) {\n        dataColorStroke.data.stroke = stroke;\n      }\n\n      if (strokeDasharray) {\n        dataColorStroke.data.strokeDasharray = strokeDasharray;\n      }\n\n      if (strokeWidth) {\n        dataColorStroke.data.strokeWidth = strokeWidth;\n      }\n\n      const defaultProps = {};\n\n      if (animate) {\n        defaultProps.animate = animate;\n      }\n\n      if (interpolation) {\n        defaultProps.interpolation = interpolation;\n      }\n\n      const chartElementProps = {\n        ...defaultProps,\n        key: `chart-${dataSet.id}-${chartType || ''}`,\n        name: `chart-${dataSet.id}-${chartType || ''}`,\n        data: dataSet.data,\n        style: { ...(dataSet.style || {}), ...dataColorStroke },\n        themeColor: dataSet.themeColor,\n        themeVariant: dataSet.themeVariant,\n        x: (xValueFormat && (datum => xValueFormat({ datum, maxX }))) || undefined,\n        y:\n          (yValueFormat &&\n            (datum =>\n              yValueFormat({\n                datum,\n                isMultiAxis: typeof maxY !== 'number',\n                maxY: typeof maxY === 'number' ? maxY : maxY?.[dataSet.id]\n              }))) ||\n          (datum => (typeof maxY === 'number' ? datum.y : datum.y / maxY?.[dataSet.id]))\n      };\n\n      const props = { ...chartElementProps };\n      const updatedProps = { chartType, props };\n\n      if (isStacked) {\n        stackedElementsById[id] = updatedProps;\n        stackedElements.push(updatedProps);\n      } else {\n        elementsById[id] = updatedProps;\n        elements.push(updatedProps);\n      }\n    }\n  });\n\n  return {\n    elements,\n    elementsById,\n    stackedElements,\n    stackedElementsById\n  };\n};\n\n/**\n * Preprocess datasets for tooltips.\n *\n * @param {object} params\n * @param {Node|Function} params.content\n * @param {Array} params.dataSets\n * @returns {{}}\n */\nconst generateTooltipData = ({ content = helpers.noop, dataSets = [] } = {}) => {\n  const tooltipDataSetLookUp = {};\n\n  if (content && dataSets?.[0]?.data) {\n    dataSets[0].data.forEach((dataSet, index) => {\n      const itemsByKey = {};\n\n      dataSets.forEach(data => {\n        if (data?.data[index]) {\n          itemsByKey[data.id] = {\n            color: data.stroke || data.fill || data.color || '',\n            chartType: data.chartType,\n            data: _cloneDeep(data.data[index])\n          };\n        }\n      });\n\n      const mockDatum = {\n        datum: { x: dataSet.x, y: dataSet.y, index, itemsByKey }\n      };\n\n      tooltipDataSetLookUp[dataSet.x] = {\n        x: dataSet.x,\n        y: null,\n        itemsByKey,\n        tooltip:\n          (React.isValidElement(content) && React.cloneElement(content, { ...mockDatum })) || content({ ...mockDatum })\n      };\n    });\n  }\n\n  return tooltipDataSetLookUp;\n};\n\n/**\n * Generate X axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {object} params.dataSet\n * @param {number} params.maxX\n * @param {number} params.xAxisLabelIncrement\n * @param {object} params.xAxisPropDefaults\n * @param {Function} params.xAxisTickFormat\n * @returns {{tickFormat: (function(*)), tickValues: *}}\n */\nconst generateXAxisProps = ({\n  dataSet = {},\n  maxX,\n  xAxisLabelIncrement,\n  xAxisPropDefaults = {},\n  xAxisTickFormat\n} = {}) => {\n  const { data = [] } = dataSet;\n  const axisProps = {\n    ...xAxisPropDefaults,\n    tickValues: data.reduce(\n      (acc, current, index) => (index % xAxisLabelIncrement === 0 ? acc.concat(current.x) : acc),\n      []\n    ),\n    tickFormat: tick => data[tick]?.xAxisLabel || tick\n  };\n\n  if (typeof xAxisTickFormat === 'function') {\n    axisProps.tickFormat = tick => {\n      const tickIndex = axisProps.tickValues.indexOf(tick);\n      const previousItem = { ...data[axisProps.tickValues[tickIndex - 1]] };\n      const nextItem = { ...data[axisProps.tickValues[tickIndex + 1]] };\n      const item = { ...data[tick] };\n\n      return xAxisTickFormat({ tick, previousItem, item, nextItem, maxX });\n    };\n  }\n\n  return axisProps;\n};\n\n/**\n * Generate Y axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number|object} params.maxY\n * @param {object} params.yAxisPropDefaults\n * @param {Function} params.yAxisTickFormat\n * @returns {Array}\n */\nconst generateYAxisProps = ({ dataSets = [], maxY, yAxisPropDefaults = {}, yAxisTickFormat } = {}) => {\n  const axisProps = [];\n  const isMultiAxis = dataSets.length > 1;\n\n  dataSets.forEach(({ id, stroke, strokeWidth } = {}, index) => {\n    const updatedAxisProps = {\n      style: { axis: {}, tickLabels: {} },\n      tickFormat: tick => tick\n    };\n\n    if (isMultiAxis && stroke) {\n      updatedAxisProps.style.axis.stroke = stroke;\n    }\n\n    if (isMultiAxis && strokeWidth) {\n      updatedAxisProps.style.axis.strokeWidth = strokeWidth;\n    }\n\n    if (typeof yAxisTickFormat === 'function') {\n      const updatedMaxY = (typeof maxY === 'number' && maxY) || maxY?.[id];\n\n      updatedAxisProps.tickFormat = tick => {\n        const normalizedTick = (isMultiAxis && tick * updatedMaxY) || tick;\n\n        return yAxisTickFormat({\n          tick: normalizedTick,\n          isMultiAxis,\n          maxY: updatedMaxY\n        });\n      };\n    }\n\n    axisProps.push({\n      ...yAxisPropDefaults,\n      ...updatedAxisProps,\n      orientation: (index === 0 && 'left') || 'right'\n    });\n  });\n\n  return axisProps;\n};\n\n/**\n * Generate x,y props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {object} params.individualMaxY\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {boolean} params.xAxisFixLabelOverlap\n * @param {number} params.xAxisLabelIncrement\n * @param {Function} params.xAxisTickFormat\n * @param {Function} params.yAxisTickFormat\n * @returns {{xAxisProps: object, yAxisProps: Array}}\n */\nconst generateAxisProps = ({\n  dataSets = [],\n  individualMaxY = {},\n  maxX,\n  maxY,\n  xAxisFixLabelOverlap = true,\n  xAxisLabelIncrement = 1,\n  xAxisTickFormat,\n  yAxisTickFormat\n} = {}) => {\n  const xAxisPropDefaults = {\n    fixLabelOverlap: xAxisFixLabelOverlap\n  };\n\n  const yAxisPropDefaults = {\n    dependentAxis: true,\n    showGrid: true\n  };\n\n  let yAxisDataSets = [];\n  let xAxisDataSet;\n\n  dataSets.forEach(dataSet => {\n    if (dataSet.yAxisUseDataSet) {\n      yAxisDataSets.push(dataSet);\n    }\n    if (dataSet.xAxisUseDataSet) {\n      xAxisDataSet = dataSet;\n    }\n  });\n\n  if (!yAxisDataSets.length) {\n    yAxisDataSets.push(dataSets?.[0]);\n  } else {\n    yAxisDataSets = yAxisDataSets.slice(0, 2);\n  }\n\n  if (!xAxisDataSet) {\n    xAxisDataSet = dataSets?.[0] || [];\n  }\n\n  const updatedMaxY = (yAxisDataSets.length > 1 && individualMaxY) || maxY;\n\n  return {\n    xAxisProps: generateXAxisProps({\n      dataSet: xAxisDataSet,\n      maxX,\n      xAxisLabelIncrement,\n      xAxisPropDefaults,\n      xAxisTickFormat\n    }),\n    yAxisProps: generateYAxisProps({ dataSets: yAxisDataSets, maxY: updatedMaxY, yAxisPropDefaults, yAxisTickFormat })\n  };\n};\n\nconst chartHelpers = {\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n\nexport {\n  chartHelpers as default,\n  chartHelpers,\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n","import { useEffect, useState } from 'react';\nimport { helpers } from '../common';\n\n/**\n * Apply a resize observer to an element.\n *\n * @param {*} target\n * @returns {{width: number, height: number}}\n */\nconst useResizeObserver = target => {\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const isElementResize = target && window.ResizeObserver && true;\n    const element = target?.current;\n    let removeObserver = helpers.noop;\n\n    if (element) {\n      const handler = () => {\n        const { clientHeight = 0, clientWidth = 0, innerHeight = 0, innerWidth = 0 } = element || {};\n\n        setDimensions({\n          width: isElementResize ? clientWidth : innerWidth,\n          height: isElementResize ? clientHeight : innerHeight\n        });\n      };\n\n      if (isElementResize) {\n        const resizeObserver = new window.ResizeObserver(handler);\n        resizeObserver.observe(element);\n        removeObserver = () => resizeObserver.unobserve(element);\n      } else {\n        handler();\n        window.addEventListener('resize', handler);\n        removeObserver = () => window.removeEventListener('resize', handler);\n      }\n    }\n\n    return () => {\n      removeObserver();\n    };\n  }, [target]);\n\n  return dimensions;\n};\n\nconst windowHooks = {\n  useResizeObserver\n};\n\nexport { windowHooks as default, windowHooks, useResizeObserver };\n","import React, { useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChartThemeColor } from '@patternfly/react-charts';\nimport { ChartContext } from './chartContext';\nimport { ChartElements } from './chartElements';\nimport { ChartLegend } from './chartLegend';\nimport { chartHelpers } from './chartHelpers';\nimport { useResizeObserver } from '../../hooks/useWindow';\n\n/**\n * Return a chart and elements with a context provider.\n *\n * @param {object} props\n * @param {Node|Function} props.chartLegend\n * @param {Node|Function} props.chartTooltip\n * @param {Array} props.dataSets\n * @param {object} props.padding\n * @param {string} props.themeColor\n * @param {boolean} props.xAxisFixLabelOverlap\n * @param {number} props.xAxisLabelIncrement\n * @param {Function} props.xAxisTickFormat\n * @param {Function} props.yAxisTickFormat\n * @param {Function} props.xValueFormat\n * @param {Function} props.yValueFormat\n * @returns {Node}\n */\nconst Chart = ({\n  chartLegend,\n  chartTooltip,\n  dataSets,\n  padding,\n  themeColor,\n  xAxisFixLabelOverlap,\n  xAxisLabelIncrement,\n  xAxisTickFormat,\n  yAxisTickFormat,\n  xValueFormat,\n  yValueFormat\n}) => {\n  const [context, setContext] = useState();\n  const [dataSetsToggle, setDataSetsToggle] = useState({});\n  const containerRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const { width: chartWidth } = useResizeObserver(containerRef);\n\n  useEffect(() => {\n    /**\n     * Aggregate chart related settings.\n     *\n     * @returns {{isMultiYAxis: boolean, padding: object, chartDomain: {domain: {y: Array}}, tooltipDataSetLookUp: {},\n     *     xAxisProps: object, themeColor: string, maxY: (object|number), hasData: boolean, maxX: number,\n     *     yAxisProps: Array, chartElementsProps: {elementsById: object, stackedElements: Array,\n     *     stackedElementsById: object, elements: Array}}}\n     */\n    const updateChartSettings = () => {\n      const toggledDataSets = dataSets.filter(({ id }) => !dataSetsToggle[id]);\n\n      const tooltipDataSetLookUp = chartHelpers.generateTooltipData({\n        content: chartTooltip,\n        dataSets: toggledDataSets\n      });\n\n      const { maxX, maxY } = chartHelpers.generateMaxXY({ dataSets: toggledDataSets });\n      const { individualMaxY } = chartHelpers.generateMaxXY({ dataSets });\n      const { xAxisProps, yAxisProps } = chartHelpers.generateAxisProps({\n        dataSets,\n        individualMaxY,\n        maxX,\n        maxY,\n        xAxisFixLabelOverlap,\n        xAxisLabelIncrement,\n        xAxisTickFormat,\n        yAxisTickFormat\n      });\n\n      const isMultiYAxis = yAxisProps.length > 1;\n      const chartElementsProps = chartHelpers.generateElementsProps({\n        dataSets: toggledDataSets,\n        maxX,\n        maxY: (isMultiYAxis && individualMaxY) || maxY,\n        xValueFormat,\n        yValueFormat\n      });\n      const chartDomain = chartHelpers.generateDomains({ maxY: (isMultiYAxis && individualMaxY) || maxY });\n      const hasData = !!xAxisProps.tickValues;\n\n      return {\n        xAxisProps,\n        yAxisProps,\n        chartDomain,\n        chartElementsProps,\n        hasData,\n        isMultiYAxis,\n        maxX,\n        maxY: (isMultiYAxis && individualMaxY) || maxY,\n        padding,\n        themeColor,\n        tooltipDataSetLookUp\n      };\n    };\n\n    const chartSettings = updateChartSettings();\n    const updatedSettings = {\n      chartContainerRef: () => containerRef,\n      chartSettings: { ...chartSettings, chartLegend, chartWidth, dataSets },\n      chartTooltipRef: () => tooltipRef,\n      dataSetsToggle: [dataSetsToggle, setDataSetsToggle]\n    };\n\n    setContext(updatedSettings);\n  }, [\n    chartLegend,\n    chartTooltip,\n    chartWidth,\n    dataSets,\n    dataSetsToggle,\n    padding,\n    setContext,\n    themeColor,\n    yAxisTickFormat,\n    xAxisTickFormat,\n    xAxisLabelIncrement,\n    xAxisFixLabelOverlap,\n    xValueFormat,\n    yValueFormat\n  ]);\n\n  return (\n    <ChartContext.Provider value={context}>\n      <div\n        id=\"curiosity-chartarea\"\n        className=\"curiosity-chartarea uxui-curiosity__modal uxui-curiosity__modal--loading\"\n        ref={containerRef}\n      >\n        {chartWidth > 0 && (\n          <React.Fragment>\n            <ChartElements />\n            <ChartLegend />\n          </React.Fragment>\n        )}\n      </div>\n    </ChartContext.Provider>\n  );\n};\n\n/**\n * Prop types.\n *\n * @type {{chartTooltip: Node|Function, xValueFormat: Function, padding: {top: number, left: number, bottom: number,\n *     right: number}, xAxisTickFormat: Function, themeColor: string, chartLegend: Node|Function,\n *     yAxisTickFormat: Function, dataSets: Array, xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number,\n *     yValueFormat: Function}}\n */\nChart.propTypes = {\n  chartLegend: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  chartTooltip: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  dataSets: PropTypes.arrayOf(\n    PropTypes.shape({\n      data: PropTypes.arrayOf(\n        PropTypes.shape({\n          x: PropTypes.number.isRequired,\n          y: PropTypes.number,\n          xAxisLabel: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        })\n      ),\n      animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n      chartType: PropTypes.oneOf(['area', 'line', 'threshold']),\n      fill: PropTypes.string,\n      stroke: PropTypes.string,\n      strokeWidth: PropTypes.number,\n      strokeDasharray: PropTypes.string,\n      themeColor: PropTypes.string,\n      themeVariant: PropTypes.string,\n      id: PropTypes.string.isRequired,\n      interpolation: PropTypes.string,\n      style: PropTypes.object,\n      isStacked: PropTypes.bool,\n      xAxisUseDataSet: PropTypes.bool,\n      yAxisUseDataSet: PropTypes.bool\n    })\n  ),\n  padding: PropTypes.shape({\n    bottom: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    top: PropTypes.number\n  }),\n  themeColor: PropTypes.oneOf(Object.values(ChartThemeColor)),\n  xAxisFixLabelOverlap: PropTypes.bool,\n  xAxisLabelIncrement: PropTypes.number,\n  xAxisTickFormat: PropTypes.func,\n  yAxisTickFormat: PropTypes.func,\n  xValueFormat: PropTypes.func,\n  yValueFormat: PropTypes.func\n};\n\n/**\n * Default props.\n *\n * @type {{chartTooltip: Node|Function, xValueFormat: Function, padding: {top: number, left: number, bottom: number,\n *     right: number}, xAxisTickFormat: Function, themeColor: string, chartLegend: Node|Function,\n *     yAxisTickFormat: Function, dataSets: Array, xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number,\n *     yValueFormat: Function}}\n */\nChart.defaultProps = {\n  chartLegend: null,\n  chartTooltip: null,\n  dataSets: [],\n  padding: {\n    bottom: 75,\n    left: 55,\n    right: 55,\n    top: 50\n  },\n  themeColor: 'blue',\n  xAxisFixLabelOverlap: true,\n  xAxisLabelIncrement: 1,\n  xAxisTickFormat: null,\n  yAxisTickFormat: null,\n  xValueFormat: null,\n  yValueFormat: null\n};\n\nexport { Chart as default, Chart };\n"],"sourceRoot":""}