{"version":3,"file":"js/8900.1659367069185.d4cf65d333acc166f14d.js","mappings":"0QA+BMA,EAAa,SAAbA,EAAc,GAAD,IACjBC,EADiB,EACjBA,cACAC,EAFiB,EAEjBA,WACAC,EAHiB,EAGjBA,UACAC,EAJiB,EAIjBA,UACAC,EALiB,EAKjBA,OACAC,EANiB,EAMjBA,OACAC,EAPiB,EAOjBA,UACAC,EARiB,EAQjBA,QACAC,EATiB,EASjBA,QATiB,OAWjB,kBAAC,aAAD,CACER,cAAeA,EACfE,UAAWA,EACXD,WAAYA,IAAeE,EAC3BA,UAAWA,EACXM,UAAW,SAACC,EAAOC,EAAMC,GAAd,OACTP,EAAO,CAAEK,MAAAA,EAAOH,QAASK,EAAOR,OAAQS,EAAAA,kBAAAA,wBAA0CF,EAAMC,IAD/E,EAGXE,gBAAiB,SAACJ,EAAOE,GAAR,OAAkBN,EAAU,CAAEI,MAAAA,EAAOH,QAASK,EAAOR,OAAQL,EAAWgB,aAAaX,QAArF,EACjBO,KAAME,EAAAA,kBAAAA,wBAA0CT,GAAUL,EAAWgB,aAAaX,OAAQG,GAC1FA,QAASA,EACTC,QAASA,GAtBM,EAoDnBT,EAAWgB,aAAe,CACxBf,cAAe,OACfE,WAAW,EACXD,YAAY,EACZE,UAAW,EACXC,OAAQ,EACRC,OAAQW,EAAAA,GAAAA,KACRV,UAAWU,EAAAA,GAAAA,KACXT,QAAS,GACTC,QAAS,K,sOCrFX,IAAMS,EAA0B,SAACN,EAAMJ,GAAP,OAAmBA,GAAWI,EAAO,IAAM,CAA3C,EAS1BO,EAA0B,SAACd,EAAQG,GAAT,OAAqBH,EAASG,EAAU,GAAK,CAA7C,EAU1BY,EAAa,SAACf,EAAQG,EAASJ,GAAlB,OACjBe,EAAwBd,EAAQG,KAAaa,KAAKC,KAAKlB,EAAYI,EADlD,EAGbM,EAAoB,CACxBI,wBAAAA,EACAC,wBAAAA,EACAC,WAAAA,E","sources":["webpack:///./src/components/pagination/pagination.js","webpack:///./src/components/pagination/paginationHelpers.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Pagination as PfPagination } from '@patternfly/react-core';\nimport { helpers } from '../../common';\nimport { paginationHelpers } from './paginationHelpers';\n\n/**\n * ToDo: Apply locale/translation to the PF Pagination \"titles\" prop.\n */\n/**\n * FixMe: PF Pagination component offset property is either broken, confusing to implement, ...\n * or requires an equivalent effort to using page. There appears to be confusing behavior in how\n * the next offset range is calculated. It fails to update when passing in the next expected\n * sequence using the returned starting index. We'll continue emulating the use of \"offset\"\n * by performing our own calculation and applying it to the page property instead.\n */\n/**\n * Pagination component.\n *\n * @param {object} props\n * @param {string} props.dropDirection\n * @param {boolean} props.isDisabled\n * @param {boolean} props.isCompact\n * @param {number} props.itemCount\n * @param {number} props.offset\n * @param {Function} props.onPage\n * @param {Function} props.onPerPage\n * @param {number} props.perPage\n * @param {string} props.variant\n * @returns {Node}\n */\nconst Pagination = ({\n  dropDirection,\n  isDisabled,\n  isCompact,\n  itemCount,\n  offset,\n  onPage,\n  onPerPage,\n  perPage,\n  variant\n}) => (\n  <PfPagination\n    dropDirection={dropDirection}\n    isCompact={isCompact}\n    isDisabled={isDisabled || !itemCount}\n    itemCount={itemCount}\n    onSetPage={(event, page, limit) =>\n      onPage({ event, perPage: limit, offset: paginationHelpers.calculateOffsetFromPage(page, limit) })\n    }\n    onPerPageSelect={(event, limit) => onPerPage({ event, perPage: limit, offset: Pagination.defaultProps.offset })}\n    page={paginationHelpers.calculatePageFromOffset(offset || Pagination.defaultProps.offset, perPage)}\n    perPage={perPage}\n    variant={variant}\n  />\n);\n\n/**\n * Prop types\n *\n * @type {{isCompact: boolean, onPage: Function, perPage: number, offset: number,\n *     dropDirection: string, onPerPage: Function, variant: null, isDisabled: boolean,\n *     itemCount: number}}\n */\nPagination.propTypes = {\n  dropDirection: PropTypes.oneOf(['up', 'down']),\n  isCompact: PropTypes.bool,\n  isDisabled: PropTypes.bool,\n  itemCount: PropTypes.number,\n  offset: PropTypes.number,\n  onPage: PropTypes.func,\n  onPerPage: PropTypes.func,\n  perPage: PropTypes.number,\n  variant: PropTypes.string\n};\n\n/**\n * Default props.\n *\n * @type {{isCompact: boolean, onPage: Function, perPage: number, offset: number,\n *     dropDirection: string, onPerPage: Function, variant: null, isDisabled: boolean,\n *     itemCount: number}}\n */\nPagination.defaultProps = {\n  dropDirection: 'down',\n  isCompact: false,\n  isDisabled: false,\n  itemCount: 0,\n  offset: 0,\n  onPage: helpers.noop,\n  onPerPage: helpers.noop,\n  perPage: 10,\n  variant: null\n};\n\nexport { Pagination as default, Pagination };\n","/**\n * Calculate offset from page and perPage/limit.\n *\n * @param {number} page\n * @param {number} perPage\n * @returns {number}\n */\nconst calculateOffsetFromPage = (page, perPage) => perPage * (page - 1) || 0;\n\n/**\n * Calculate page from offset and perPage/limit\n *\n * @param {number} offset\n * @param {number} perPage\n * @returns {number}\n */\nconst calculatePageFromOffset = (offset, perPage) => offset / perPage + 1 || 1;\n\n/**\n * Determine if paging is on the last page.\n *\n * @param {number} offset\n * @param {number} perPage\n * @param {number} itemCount\n * @returns {boolean}\n */\nconst isLastPage = (offset, perPage, itemCount) =>\n  calculatePageFromOffset(offset, perPage) === Math.ceil(itemCount / perPage);\n\nconst paginationHelpers = {\n  calculateOffsetFromPage,\n  calculatePageFromOffset,\n  isLastPage\n};\n\nexport {\n  paginationHelpers as default,\n  paginationHelpers,\n  calculateOffsetFromPage,\n  calculatePageFromOffset,\n  isLastPage\n};\n"],"names":["Pagination","dropDirection","isDisabled","isCompact","itemCount","offset","onPage","onPerPage","perPage","variant","onSetPage","event","page","limit","paginationHelpers","onPerPageSelect","defaultProps","helpers","calculateOffsetFromPage","calculatePageFromOffset","isLastPage","Math","ceil"],"sourceRoot":""}