{"version":3,"file":"js/1026.74e8fd0a01d162859793.js","mappings":"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","sources":["webpack:///./src/components/chart/chartHelpers.js"],"sourcesContent":["import React from 'react';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { helpers } from '../../common';\n\n/**\n * Generate max X and Y values from datasets.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @returns {{individualMaxY: object, maxY: number, maxX: number}}\n */\nconst generateMaxXY = ({ dataSets = [] } = {}) => {\n  const individualDataSetsMaxY = {};\n  let combinedDataSetMaxX = 0;\n  let combinedDataSetsMaxY = 0;\n\n  dataSets\n    .filter(({ isStacked }) => isStacked === true)\n    .forEach(({ data }) => {\n      if (Array.isArray(data)) {\n        combinedDataSetsMaxY += Math.max(...data.map(value => value?.y ?? 0));\n      }\n    });\n\n  dataSets.forEach(({ id, data }) => {\n    let dataSetMaxY = 0;\n\n    if (Array.isArray(data)) {\n      combinedDataSetMaxX = data.length > combinedDataSetMaxX ? data.length : combinedDataSetMaxX;\n\n      dataSetMaxY = Math.max(...data.map(value => value?.y ?? 0));\n      combinedDataSetsMaxY = dataSetMaxY > combinedDataSetsMaxY ? dataSetMaxY : combinedDataSetsMaxY;\n    }\n\n    if (id) {\n      individualDataSetsMaxY[id] = dataSetMaxY;\n    }\n  });\n\n  return {\n    maxX: combinedDataSetMaxX,\n    maxY: combinedDataSetsMaxY,\n    individualMaxY: individualDataSetsMaxY\n  };\n};\n\n/**\n * Generate Y axis domain ranges from dataSets, ignore X axis.\n *\n * @param {object} params\n * @param {number|object} params.maxY\n * @returns {{ domain: { y: Array } }}\n */\nconst generateDomains = ({ maxY } = {}) => {\n  const updatedChartDomain = {};\n  const generatedDomain = {};\n\n  if (Object.values(maxY).length) {\n    generatedDomain.y = [0, 1.25];\n  } else {\n    const floored = Math.pow(10, Math.floor(Math.log10(maxY || 10)));\n    generatedDomain.y = [0, Math.ceil((maxY + 1) / floored) * floored];\n  }\n\n  if (Object.keys(generatedDomain).length) {\n    updatedChartDomain.domain = generatedDomain;\n  }\n\n  return {\n    ...updatedChartDomain\n  };\n};\n\n/**\n * Generate chart element props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {Function} params.xValueFormat\n * @param {Function} params.yValueFormat\n * @returns {{elementsById: object, stackedElements: Array, stackedElementsById: object, elements: Array}}\n */\nconst generateElementsProps = ({ dataSets = [], maxX, maxY, xValueFormat, yValueFormat }) => {\n  const elements = [];\n  const stackedElements = [];\n  const elementsById = {};\n  const stackedElementsById = {};\n\n  dataSets.forEach(dataSet => {\n    const {\n      animate,\n      chartType,\n      data,\n      fill,\n      id,\n      isStacked,\n      interpolation,\n      stroke,\n      strokeDasharray,\n      strokeWidth\n    } = dataSet;\n\n    if (data?.length) {\n      const dataColorStroke = {\n        data: {}\n      };\n\n      if (fill && chartType !== 'line' && chartType !== 'threshold') {\n        dataColorStroke.data.fill = fill;\n      }\n\n      if (stroke) {\n        dataColorStroke.data.stroke = stroke;\n      }\n\n      if (strokeDasharray) {\n        dataColorStroke.data.strokeDasharray = strokeDasharray;\n      }\n\n      if (strokeWidth) {\n        dataColorStroke.data.strokeWidth = strokeWidth;\n      }\n\n      const defaultProps = {};\n\n      if (animate) {\n        defaultProps.animate = animate;\n      }\n\n      if (interpolation) {\n        defaultProps.interpolation = interpolation;\n      }\n\n      const chartElementProps = {\n        ...defaultProps,\n        key: `chart-${dataSet.id}-${chartType || ''}`,\n        name: `chart-${dataSet.id}-${chartType || ''}`,\n        data: dataSet.data,\n        style: { ...(dataSet.style || {}), ...dataColorStroke },\n        themeColor: dataSet.themeColor,\n        themeVariant: dataSet.themeVariant,\n        x:\n          (xValueFormat &&\n            (datum => {\n              const xValue = xValueFormat({ datum, maxX });\n              return xValue === undefined || Number.isNaN(xValue) ? 0 : xValue;\n            })) ||\n          undefined,\n        y: datum => {\n          let yValue;\n\n          if (yValueFormat) {\n            yValue = yValueFormat({\n              datum,\n              isMultiAxis: typeof maxY !== 'number',\n              maxY: typeof maxY === 'number' ? maxY : maxY?.[dataSet.id]\n            });\n          } else {\n            yValue = typeof maxY === 'number' ? datum.y : datum.y / maxY?.[dataSet.id];\n          }\n\n          return yValue === undefined || Number.isNaN(yValue) ? 0 : yValue;\n        }\n      };\n\n      const props = { ...chartElementProps };\n      const updatedProps = { chartType, props };\n\n      if (isStacked) {\n        stackedElementsById[id] = updatedProps;\n        stackedElements.push(updatedProps);\n      } else {\n        elementsById[id] = updatedProps;\n        elements.push(updatedProps);\n      }\n    }\n  });\n\n  return {\n    elements,\n    elementsById,\n    stackedElements,\n    stackedElementsById\n  };\n};\n\n/**\n * Preprocess datasets for tooltips.\n *\n * @param {object} params\n * @param {Node|Function} params.content\n * @param {Array} params.dataSets\n * @returns {{}}\n */\nconst generateTooltipData = ({ content = helpers.noop, dataSets = [] } = {}) => {\n  const tooltipDataSetLookUp = {};\n\n  if (content && dataSets?.[0]?.data) {\n    dataSets[0].data.forEach((dataSet, index) => {\n      const itemsByKey = {};\n\n      dataSets.forEach(data => {\n        if (data?.data[index]) {\n          itemsByKey[data.id] = {\n            color: data.stroke || data.fill || data.color || '',\n            chartType: data.chartType,\n            data: _cloneDeep(data.data[index])\n          };\n        }\n      });\n\n      const mockDatum = {\n        datum: { x: dataSet.x, y: dataSet.y, index, itemsByKey }\n      };\n\n      tooltipDataSetLookUp[dataSet.x] = {\n        x: dataSet.x,\n        y: null,\n        itemsByKey,\n        tooltip:\n          (React.isValidElement(content) && React.cloneElement(content, { ...mockDatum })) || content({ ...mockDatum })\n      };\n    });\n  }\n\n  return tooltipDataSetLookUp;\n};\n\n/**\n * Generate X axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {object} params.dataSet\n * @param {number} params.maxX\n * @param {number} params.xAxisLabelIncrement\n * @param {object} params.xAxisPropDefaults\n * @param {Function} params.xAxisTickFormat\n * @returns {{tickFormat: (function(*)), tickValues: *}}\n */\nconst generateXAxisProps = ({\n  dataSet = {},\n  maxX,\n  xAxisLabelIncrement,\n  xAxisPropDefaults = {},\n  xAxisTickFormat\n} = {}) => {\n  const { data = [] } = dataSet;\n  const axisProps = {\n    ...xAxisPropDefaults,\n    tickValues: data.reduce(\n      (acc, current, index) => (index % xAxisLabelIncrement === 0 ? acc.concat(current.x) : acc),\n      []\n    ),\n    tickFormat: tick => data[tick]?.xAxisLabel || tick\n  };\n\n  if (typeof xAxisTickFormat === 'function') {\n    axisProps.tickFormat = tick => {\n      const tickIndex = axisProps.tickValues.indexOf(tick);\n      const previousItem = { ...data[axisProps.tickValues[tickIndex - 1]] };\n      const nextItem = { ...data[axisProps.tickValues[tickIndex + 1]] };\n      const item = { ...data[tick] };\n\n      return xAxisTickFormat({ tick, previousItem, item, nextItem, maxX });\n    };\n  }\n\n  return axisProps;\n};\n\n/**\n * Generate Y axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number|object} params.maxY\n * @param {object} params.yAxisPropDefaults\n * @param {Function} params.yAxisTickFormat\n * @returns {Array}\n */\nconst generateYAxisProps = ({ dataSets = [], maxY, yAxisPropDefaults = {}, yAxisTickFormat } = {}) => {\n  const axisProps = [];\n  const isMultiAxis = dataSets.length > 1;\n\n  dataSets.forEach(({ id, stroke, strokeWidth } = {}, index) => {\n    const updatedAxisProps = {\n      style: { axis: {}, tickLabels: {} },\n      tickFormat: tick => tick\n    };\n\n    if (isMultiAxis && stroke) {\n      updatedAxisProps.style.axis.stroke = stroke;\n    }\n\n    if (isMultiAxis && strokeWidth) {\n      updatedAxisProps.style.axis.strokeWidth = strokeWidth;\n    }\n\n    if (typeof yAxisTickFormat === 'function') {\n      const updatedMaxY = (typeof maxY === 'number' && maxY) || maxY?.[id];\n\n      updatedAxisProps.tickFormat = tick => {\n        const normalizedTick = (isMultiAxis && tick * updatedMaxY) || tick;\n\n        return yAxisTickFormat({\n          tick: normalizedTick,\n          isMultiAxis,\n          maxY: updatedMaxY\n        });\n      };\n    }\n\n    axisProps.push({\n      ...yAxisPropDefaults,\n      ...updatedAxisProps,\n      orientation: (index === 0 && 'left') || 'right'\n    });\n  });\n\n  return axisProps;\n};\n\n/**\n * Generate x,y props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {object} params.individualMaxY\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {boolean} params.xAxisFixLabelOverlap\n * @param {number} params.xAxisLabelIncrement\n * @param {Function} params.xAxisTickFormat\n * @param {Function} params.yAxisTickFormat\n * @returns {{xAxisProps: object, yAxisProps: Array}}\n */\nconst generateAxisProps = ({\n  dataSets = [],\n  individualMaxY = {},\n  maxX,\n  maxY,\n  xAxisFixLabelOverlap = true,\n  xAxisLabelIncrement = 1,\n  xAxisTickFormat,\n  yAxisTickFormat\n} = {}) => {\n  const xAxisPropDefaults = {\n    fixLabelOverlap: xAxisFixLabelOverlap\n  };\n\n  const yAxisPropDefaults = {\n    dependentAxis: true,\n    showGrid: true\n  };\n\n  let yAxisDataSets = [];\n  let xAxisDataSet;\n\n  dataSets.forEach(dataSet => {\n    if (dataSet.yAxisUseDataSet) {\n      yAxisDataSets.push(dataSet);\n    }\n    if (dataSet.xAxisUseDataSet) {\n      xAxisDataSet = dataSet;\n    }\n  });\n\n  if (!yAxisDataSets.length) {\n    yAxisDataSets.push(dataSets?.[0]);\n  } else {\n    yAxisDataSets = yAxisDataSets.slice(0, 2);\n  }\n\n  if (!xAxisDataSet) {\n    xAxisDataSet = dataSets?.[0] || [];\n  }\n\n  const updatedMaxY = (yAxisDataSets.length > 1 && individualMaxY) || maxY;\n\n  return {\n    xAxisProps: generateXAxisProps({\n      dataSet: xAxisDataSet,\n      maxX,\n      xAxisLabelIncrement,\n      xAxisPropDefaults,\n      xAxisTickFormat\n    }),\n    yAxisProps: generateYAxisProps({ dataSets: yAxisDataSets, maxY: updatedMaxY, yAxisPropDefaults, yAxisTickFormat })\n  };\n};\n\nconst chartHelpers = {\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n\nexport {\n  chartHelpers as default,\n  chartHelpers,\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n"],"names":["generateMaxXY","dataSets","individualDataSetsMaxY","combinedDataSetMaxX","combinedDataSetsMaxY","filter","isStacked","forEach","data","Array","isArray","Math","max","map","value","y","id","dataSetMaxY","length","maxX","maxY","individualMaxY","generateDomains","updatedChartDomain","generatedDomain","Object","values","floored","pow","floor","log10","ceil","keys","domain","generateElementsProps","xValueFormat","yValueFormat","elements","stackedElements","elementsById","stackedElementsById","dataSet","animate","chartType","fill","interpolation","stroke","strokeDasharray","strokeWidth","dataColorStroke","defaultProps","chartElementProps","key","name","style","themeColor","themeVariant","x","datum","xValue","undefined","Number","isNaN","yValue","isMultiAxis","updatedProps","props","push","generateTooltipData","content","helpers","tooltipDataSetLookUp","index","itemsByKey","color","_cloneDeep","mockDatum","tooltip","React","generateXAxisProps","xAxisLabelIncrement","xAxisPropDefaults","xAxisTickFormat","axisProps","tickValues","reduce","acc","current","concat","tickFormat","tick","xAxisLabel","tickIndex","indexOf","previousItem","nextItem","item","generateYAxisProps","yAxisPropDefaults","yAxisTickFormat","updatedAxisProps","axis","tickLabels","updatedMaxY","orientation","generateAxisProps","xAxisDataSet","xAxisFixLabelOverlap","fixLabelOverlap","dependentAxis","showGrid","yAxisDataSets","yAxisUseDataSet","xAxisUseDataSet","slice","xAxisProps","yAxisProps","chartHelpers"],"sourceRoot":""}