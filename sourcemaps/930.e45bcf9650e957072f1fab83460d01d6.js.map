{"version":3,"file":"js/930.1665413144649.60dd60f79778b195cd79.js","mappings":"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","sources":["webpack:///./src/components/chart/chart.js","webpack:///./src/hooks/useWindow.js","webpack:///./src/components/chart/chartAxisLabel.js","webpack:///./src/components/chart/chartContext.js","webpack:///./src/components/chart/chartElements.js","webpack:///./src/components/chart/chartHelpers.js","webpack:///./src/components/chart/chartLegend.js","webpack:///./src/components/chart/chartTooltip.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChartThemeColor } from '@patternfly/react-charts';\nimport { ChartContext } from './chartContext';\nimport { ChartElements } from './chartElements';\nimport { ChartLegend } from './chartLegend';\nimport { chartHelpers } from './chartHelpers';\nimport { useResizeObserver } from '../../hooks/useWindow';\n\n/**\n * Return a chart and elements with a context provider.\n *\n * @param {object} props\n * @param {Node|Function} props.chartLegend\n * @param {Node|Function} props.chartTooltip\n * @param {Array} props.dataSets\n * @param {object} props.padding\n * @param {string} props.themeColor\n * @param {Node|Function} props.xAxisChartLabel\n * @param {Node|Function} props.yAxisChartLabel\n * @param {boolean} props.xAxisFixLabelOverlap\n * @param {number} props.xAxisLabelIncrement\n * @param {Function} props.xAxisTickFormat\n * @param {Function} props.yAxisTickFormat\n * @param {Function} props.xValueFormat\n * @param {Function} props.yValueFormat\n * @returns {Node}\n */\nconst Chart = ({\n  chartLegend,\n  chartTooltip,\n  dataSets,\n  padding,\n  themeColor,\n  xAxisChartLabel,\n  yAxisChartLabel,\n  xAxisFixLabelOverlap,\n  xAxisLabelIncrement,\n  xAxisTickFormat,\n  yAxisTickFormat,\n  xValueFormat,\n  yValueFormat\n}) => {\n  const [context, setContext] = useState();\n  const [dataSetsToggle, setDataSetsToggle] = useState({});\n  const containerRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const { width: chartWidth } = useResizeObserver(containerRef);\n\n  useEffect(() => {\n    /**\n     * Aggregate chart related settings.\n     *\n     * @returns {{isMultiYAxis: boolean, padding: object, chartDomain: {domain: {y: Array}}, tooltipDataSetLookUp: {},\n     *     xAxisProps: object, themeColor: string, maxY: (object|number), hasData: boolean, maxX: number,\n     *     yAxisProps: Array, chartElementsProps: {elementsById: object, stackedElements: Array,\n     *     stackedElementsById: object, elements: Array}}}\n     */\n    const updateChartSettings = () => {\n      const toggledDataSets = dataSets.filter(({ id }) => !dataSetsToggle[id]);\n\n      const tooltipDataSetLookUp = chartHelpers.generateTooltipData({\n        content: chartTooltip,\n        dataSets: toggledDataSets\n      });\n\n      const { maxX, maxY } = chartHelpers.generateMaxXY({ dataSets: toggledDataSets });\n      const { individualMaxY } = chartHelpers.generateMaxXY({ dataSets });\n      const { xAxisProps, yAxisProps } = chartHelpers.generateAxisProps({\n        dataSets,\n        individualMaxY,\n        maxX,\n        maxY,\n        xAxisChartLabel,\n        yAxisChartLabel,\n        xAxisFixLabelOverlap,\n        xAxisLabelIncrement,\n        xAxisTickFormat,\n        yAxisTickFormat\n      });\n\n      const isMultiYAxis = yAxisProps.length > 1;\n      const chartElementsProps = chartHelpers.generateElementsProps({\n        dataSets: toggledDataSets,\n        maxX,\n        maxY: (isMultiYAxis && individualMaxY) || maxY,\n        xValueFormat,\n        yValueFormat\n      });\n      const { domain, padding: domainPadding } = chartHelpers.generateDomains({\n        maxY: (isMultiYAxis && individualMaxY) || maxY,\n        padding\n      });\n      const hasData = !!xAxisProps.tickValues;\n      const updatedPadding = { bottom: 0, left: 0, right: 0, top: 0, ...padding, ...domainPadding };\n\n      return {\n        xAxisProps,\n        yAxisProps,\n        chartDomain: { domain },\n        chartElementsProps,\n        hasData,\n        isMultiYAxis,\n        maxX,\n        maxY: (isMultiYAxis && individualMaxY) || maxY,\n        padding: updatedPadding,\n        themeColor,\n        tooltipDataSetLookUp\n      };\n    };\n\n    const chartSettings = updateChartSettings();\n    const updatedSettings = {\n      chartContainerRef: () => containerRef,\n      chartSettings: { ...chartSettings, chartLegend, chartWidth, dataSets },\n      chartTooltipRef: () => tooltipRef,\n      dataSetsToggle: [dataSetsToggle, setDataSetsToggle]\n    };\n\n    setContext(updatedSettings);\n  }, [\n    chartLegend,\n    chartTooltip,\n    chartWidth,\n    dataSets,\n    dataSetsToggle,\n    padding,\n    setContext,\n    themeColor,\n    xAxisChartLabel,\n    yAxisChartLabel,\n    xAxisFixLabelOverlap,\n    xAxisLabelIncrement,\n    yAxisTickFormat,\n    xAxisTickFormat,\n    xValueFormat,\n    yValueFormat\n  ]);\n\n  return (\n    <ChartContext.Provider value={context}>\n      <div\n        id=\"curiosity-chartarea\"\n        className=\"curiosity-chartarea uxui-curiosity__modal uxui-curiosity__modal--loading\"\n        ref={containerRef}\n      >\n        {chartWidth > 0 && (\n          <React.Fragment>\n            <ChartElements />\n            <ChartLegend />\n          </React.Fragment>\n        )}\n      </div>\n    </ChartContext.Provider>\n  );\n};\n\n/**\n * Prop types.\n *\n * @type {{chartTooltip: Node|Function, xValueFormat: Function, padding: {top: number, left: number, bottom: number,\n *     right: number}, xAxisTickFormat: Function, themeColor: string, chartLegend: Node|Function,\n *     yAxisTickFormat: Function, dataSets: Array, xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number,\n *     yValueFormat: Function}}\n */\nChart.propTypes = {\n  chartLegend: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  chartTooltip: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  dataSets: PropTypes.arrayOf(\n    PropTypes.shape({\n      data: PropTypes.arrayOf(\n        PropTypes.shape({\n          x: PropTypes.number.isRequired,\n          y: PropTypes.number,\n          xAxisLabel: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        })\n      ),\n      animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n      chartType: PropTypes.oneOf(['area', 'line', 'threshold']),\n      fill: PropTypes.string,\n      stroke: PropTypes.string,\n      strokeWidth: PropTypes.number,\n      strokeDasharray: PropTypes.string,\n      themeColor: PropTypes.string,\n      themeVariant: PropTypes.string,\n      id: PropTypes.string.isRequired,\n      interpolation: PropTypes.string,\n      style: PropTypes.object,\n      isStacked: PropTypes.bool,\n      xAxisChartLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n      yAxisChartLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n      xAxisUseDataSet: PropTypes.bool,\n      yAxisUseDataSet: PropTypes.bool\n    })\n  ),\n  padding: PropTypes.shape({\n    bottom: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    top: PropTypes.number\n  }),\n  themeColor: PropTypes.oneOf(Object.values(ChartThemeColor)),\n  xAxisChartLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  yAxisChartLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  xAxisFixLabelOverlap: PropTypes.bool,\n  xAxisLabelIncrement: PropTypes.number,\n  xAxisTickFormat: PropTypes.func,\n  yAxisTickFormat: PropTypes.func,\n  xValueFormat: PropTypes.func,\n  yValueFormat: PropTypes.func\n};\n\n/**\n * Default props.\n *\n * @type {{chartTooltip: Node|Function, xValueFormat: Function, padding: {top: number, left: number, bottom: number,\n *     right: number}, xAxisTickFormat: Function, themeColor: string, chartLegend: Node|Function,\n *     yAxisTickFormat: Function, dataSets: Array, xAxisFixLabelOverlap: boolean, xAxisLabelIncrement: number,\n *     yValueFormat: Function}}\n */\nChart.defaultProps = {\n  chartLegend: null,\n  chartTooltip: null,\n  dataSets: [],\n  padding: {\n    bottom: 75,\n    left: 55,\n    right: 55,\n    top: 50\n  },\n  themeColor: 'blue',\n  xAxisChartLabel: null,\n  yAxisChartLabel: null,\n  xAxisFixLabelOverlap: true,\n  xAxisLabelIncrement: 1,\n  xAxisTickFormat: null,\n  yAxisTickFormat: null,\n  xValueFormat: null,\n  yValueFormat: null\n};\n\nexport { Chart as default, Chart };\n","import { useEffect, useState } from 'react';\nimport { helpers } from '../common';\n\n/**\n * Apply a resize observer to an element.\n *\n * @param {*} target\n * @returns {{width: number, height: number}}\n */\nconst useResizeObserver = target => {\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const isElementResize = target && window.ResizeObserver && true;\n    const element = target?.current;\n    let removeObserver = helpers.noop;\n\n    if (element) {\n      const handler = () => {\n        const { clientHeight = 0, clientWidth = 0, innerHeight = 0, innerWidth = 0 } = element || {};\n\n        setDimensions({\n          width: isElementResize ? clientWidth : innerWidth,\n          height: isElementResize ? clientHeight : innerHeight\n        });\n      };\n\n      if (isElementResize) {\n        const resizeObserver = new window.ResizeObserver(handler);\n        resizeObserver.observe(element);\n        removeObserver = () => resizeObserver.unobserve(element);\n      } else {\n        handler();\n        window.addEventListener('resize', handler);\n        removeObserver = () => window.removeEventListener('resize', handler);\n      }\n    }\n\n    return () => {\n      removeObserver();\n    };\n  }, [target]);\n\n  return dimensions;\n};\n\nconst windowHooks = {\n  useResizeObserver\n};\n\nexport { windowHooks as default, windowHooks, useResizeObserver };\n","import React from 'react';\n\n/**\n * Note: Victory Charts components require a form of extended \"something\" applied by the consuming component.\n * This leads to odd implementations, like returning a function component.\n */\n/**\n * Return a compatible Victory tooltip component.\n *\n * @param {object} params\n * @param {string} params.axis\n * @param {number} params.index\n * @returns {Function}\n */\nconst chartAxisLabel =\n  ({ axis, index = 0 } = {}) =>\n  ({ x, y, text }) => // eslint-disable-line\n    (\n      <g>\n        <foreignObject x={0} y={0} width=\"100%\" height=\"100%\">\n          <div\n            className={`curiosity-chartarea__axis-label-container curiosity-chartarea__axis-label-container-${axis} curiosity-chartarea__axis-label-container-${axis}-${index}`}\n            style={{ top: `${y ?? 0}px` }}\n            xmlns=\"http://www.w3.org/1999/xhtml\"\n          >\n            <div className=\"curiosity-chartarea__axis-label-container-content\">{text}</div>\n          </div>\n        </foreignObject>\n      </g>\n    );\n\nexport { chartAxisLabel as default, chartAxisLabel };\n","import React, { useCallback, useContext } from 'react';\nimport { helpers } from '../../common';\n\n/**\n * Chart context.\n *\n * @type {React.Context<{}>}\n */\nconst DEFAULT_CONTEXT = [\n  { chartContainerRef: helpers.noop, chartSettings: {}, chartTooltipRef: helpers.noop, dataSetsToggle: [] },\n  helpers.noop\n];\n\nconst ChartContext = React.createContext(DEFAULT_CONTEXT);\n\n/**\n * Get an updated chart context.\n *\n * @returns {React.Context<{}>}\n */\nconst useChartContext = () => useContext(ChartContext);\n\n/**\n * ToDo: reevaluate this alternative pattern of passing hooks as options, helps testing\n */\n/**\n * Track, show, and hide chart data layers.\n *\n * @param {object} options\n * @param {Function} options.useChartContext\n * @returns {{onRevert: Function, onToggle: Function, getIsToggled: Function, dataSetsToggle: object,\n *     onHide: Function}}\n */\nconst useToggleData = ({ useChartContext: useAliasChartContext = useChartContext } = {}) => {\n  const { dataSetsToggle: contextDataSetsToggle = [] } = useAliasChartContext();\n  const [dataSetsToggle, setDataSetsToggle] = contextDataSetsToggle;\n\n  /**\n   * Hide a graph layer.\n   *\n   * @type {(function(*): void)|*}\n   */\n  const onHide = useCallback(\n    id => {\n      setDataSetsToggle(prevState => ({ ...prevState, [id]: true }));\n    },\n    [setDataSetsToggle]\n  );\n\n  // ToDo: re-evaluate useCallback here.\n  /**\n   * Reset graph layers.\n   *\n   * @type {(function(): void)|*}\n   */\n  const onRevert = useCallback(() => {\n    setDataSetsToggle(() => ({}));\n  }, [setDataSetsToggle]);\n\n  /**\n   * Hide/show graph layers.\n   *\n   * @type {function(*): boolean}\n   */\n  const onToggle = useCallback(\n    id => {\n      const updatedToggle = !dataSetsToggle?.[id];\n      setDataSetsToggle(prevState => ({ ...prevState, [id]: updatedToggle }));\n      return updatedToggle;\n    },\n    [dataSetsToggle, setDataSetsToggle]\n  );\n\n  // ToDo: review return undefined if doesn't exist\n  /**\n   * Graph layer status.\n   *\n   * @type {function(*): boolean}\n   */\n  const getIsToggled = useCallback(id => dataSetsToggle?.[id] || false, [dataSetsToggle]);\n\n  return {\n    ...{ dataSetsToggle },\n    onHide,\n    onRevert,\n    onToggle,\n    getIsToggled\n  };\n};\n\nconst context = {\n  ChartContext,\n  DEFAULT_CONTEXT,\n  useChartContext,\n  useToggleData\n};\n\nexport { context as default, context, ChartContext, DEFAULT_CONTEXT, useChartContext, useToggleData };\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { VictoryStack as ChartStack, VictoryTooltip as ChartCursorTooltip } from 'victory';\nimport { createContainer } from 'victory-create-container';\nimport { Chart, ChartArea, ChartAxis, ChartContainer, ChartLine, ChartThreshold } from '@patternfly/react-charts';\nimport { useChartContext } from './chartContext';\nimport { chartTooltip } from './chartTooltip';\nimport { chartAxisLabel } from './chartAxisLabel';\n\n/**\n * Generate a compatible Victory chart element/facet component.\n *\n * @param {object} props\n * @param {object} props.chartTypeDefaults\n * @returns {Node}\n */\nconst ChartElements = ({ chartTypeDefaults }) => {\n  const { chartSettings = {}, chartContainerRef, chartTooltipRef } = useChartContext();\n  const {\n    chartDomain,\n    chartElementsProps,\n    chartWidth,\n    hasData,\n    padding,\n    themeColor,\n    xAxisProps = {},\n    yAxisProps = []\n  } = chartSettings;\n\n  let containerComponent = <ChartContainer />;\n  let xAxis = null;\n  let yAxis = null;\n  let chartElements = [];\n  let stackedChartElements = [];\n\n  if (hasData) {\n    /**\n     * Note: both cursor and voronoiDimension attrs required if the need is to have...\n     * the tooltip populate consistently without being \"near\" a chart element y axis point\n     */\n    const VictoryVoronoiCursorContainer = createContainer('voronoi', 'cursor');\n    const TooltipLabelComponent = chartTooltip({ chartSettings, chartContainerRef, chartTooltipRef });\n\n    containerComponent = (\n      <VictoryVoronoiCursorContainer\n        cursorDimension=\"x\"\n        voronoiDimension=\"x\"\n        labels={obj => obj}\n        labelComponent={\n          <ChartCursorTooltip\n            dx={0}\n            dy={0}\n            centerOffset={{ x: 0, y: 0 }}\n            flyoutStyle={{ fill: 'transparent', stroke: 'transparent' }}\n            labelComponent={<TooltipLabelComponent />}\n          />\n        }\n        voronoiPadding={(padding && Object.values(padding).sort()?.[0]) || 0}\n        mouseFollowTooltips\n      />\n    );\n  }\n\n  /**\n   * Generate X Axis\n   */\n  if (Object.keys(xAxisProps).length) {\n    const updatedXAxisProps = {\n      ...xAxisProps\n    };\n\n    if (updatedXAxisProps.label) {\n      const AxisLabelComponent = chartAxisLabel({ axis: 'x' });\n      updatedXAxisProps.axisLabelComponent = <AxisLabelComponent />;\n    }\n\n    xAxis = <ChartAxis {...updatedXAxisProps} animate={false} />;\n  }\n\n  /**\n   * Generate Y Axis\n   */\n  if (Array.isArray(yAxisProps)) {\n    yAxis = yAxisProps.map((axisProps, index) => {\n      const updatedAxisProps = {\n        ...axisProps\n      };\n\n      if (updatedAxisProps.label) {\n        const AxisLabelComponent = chartAxisLabel({ axis: 'y', index });\n        updatedAxisProps.axisLabelComponent = <AxisLabelComponent />;\n      }\n\n      return <ChartAxis key={`yaxis-${axisProps.orientation}`} {...updatedAxisProps} animate={false} />;\n    });\n  }\n\n  const setChartElement = ({ chartType, props }) => {\n    const { component: Component, ...defaultProps } = chartTypeDefaults[chartType] || chartTypeDefaults.area;\n    return <Component {...{ ...defaultProps, ...props }} />;\n  };\n\n  chartElements = chartElementsProps?.elements.map(setChartElement);\n  stackedChartElements = chartElementsProps?.stackedElements.map(setChartElement);\n\n  return (\n    <Chart\n      animate={{ duration: 0 }}\n      width={chartWidth}\n      themeColor={themeColor}\n      {...{ padding, containerComponent, ...chartDomain }}\n    >\n      {xAxis}\n      {yAxis}\n      {chartElements}\n      <ChartStack>{stackedChartElements}</ChartStack>\n    </Chart>\n  );\n};\n\nChartElements.propTypes = {\n  chartTypeDefaults: PropTypes.objectOf(\n    PropTypes.shape({\n      component: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n      animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n      interpolation: PropTypes.oneOf(['monotoneX', 'step'])\n    })\n  )\n};\n\nChartElements.defaultProps = {\n  chartTypeDefaults: {\n    area: {\n      component: ChartArea,\n      animate: {\n        duration: 250,\n        onLoad: { duration: 250 }\n      },\n      interpolation: 'monotoneX'\n    },\n    line: {\n      component: ChartLine,\n      animate: {\n        duration: 250,\n        onLoad: { duration: 250 }\n      },\n      interpolation: 'monotoneX'\n    },\n    threshold: {\n      component: ChartThreshold,\n      animate: {\n        duration: 100,\n        onLoad: { duration: 100 }\n      },\n      interpolation: 'step'\n    }\n  }\n};\n\nexport { ChartElements as default, ChartElements };\n","import React from 'react';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { helpers } from '../../common';\n\n/**\n * Generate max X and Y values from datasets.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @returns {{individualMaxY: object, maxY: number, maxX: number}}\n */\nconst generateMaxXY = ({ dataSets = [] } = {}) => {\n  const individualDataSetsMaxY = {};\n  let combinedDataSetMaxX = 0;\n  let combinedDataSetsMaxY = 0;\n\n  dataSets\n    .filter(({ isStacked }) => isStacked === true)\n    .forEach(({ data }) => {\n      if (Array.isArray(data)) {\n        combinedDataSetsMaxY += Math.max(...data.map(value => value?.y ?? 0));\n      }\n    });\n\n  dataSets.forEach(({ id, data }) => {\n    let dataSetMaxY = 0;\n\n    if (Array.isArray(data)) {\n      combinedDataSetMaxX = data.length > combinedDataSetMaxX ? data.length : combinedDataSetMaxX;\n\n      dataSetMaxY = Math.max(...data.map(value => value?.y ?? 0));\n      combinedDataSetsMaxY = dataSetMaxY > combinedDataSetsMaxY ? dataSetMaxY : combinedDataSetsMaxY;\n    }\n\n    if (id) {\n      individualDataSetsMaxY[id] = dataSetMaxY;\n    }\n  });\n\n  return {\n    maxX: combinedDataSetMaxX,\n    maxY: combinedDataSetsMaxY,\n    individualMaxY: individualDataSetsMaxY\n  };\n};\n\n/**\n * Generate Y axis domain ranges from dataSets, ignore X axis.\n *\n * @param {object} params\n * @param {number|object} params.maxY\n * @param {object} params.padding\n * @returns {{ domain: { y: Array }, padding: {object} }}\n */\nconst generateDomains = ({ maxY, padding = {} } = {}) => {\n  const updatedChartDomain = {};\n  const updatedPadding = { ...padding };\n  const generatedDomain = {};\n\n  if (Object.values(maxY).length) {\n    generatedDomain.y = [0, 1.25];\n  } else if (maxY >= 0.1) {\n    const floored = Math.pow(10, Math.floor(Math.log10(maxY || 10)));\n    generatedDomain.y = [0, Math.ceil((maxY + 1) / floored) * floored];\n  } else if (maxY < 0.1) {\n    generatedDomain.y = [0, maxY + maxY / 4 || 10];\n  } else {\n    generatedDomain.y = [0, 10];\n  }\n\n  if (maxY < 0.01) {\n    updatedPadding.left += generatedDomain.y.toString().length;\n    updatedPadding.right += generatedDomain.y.toString().length;\n  }\n\n  if (Object.keys(generatedDomain).length) {\n    updatedChartDomain.domain = generatedDomain;\n  }\n\n  return {\n    ...updatedChartDomain,\n    padding: updatedPadding\n  };\n};\n\n/**\n * Generate chart element props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {Function} params.xValueFormat\n * @param {Function} params.yValueFormat\n * @returns {{elementsById: object, stackedElements: Array, stackedElementsById: object, elements: Array}}\n */\nconst generateElementsProps = ({ dataSets = [], maxX, maxY, xValueFormat, yValueFormat }) => {\n  const elements = [];\n  const stackedElements = [];\n  const elementsById = {};\n  const stackedElementsById = {};\n\n  dataSets.forEach(dataSet => {\n    const { animate, chartType, data, fill, id, isStacked, interpolation, stroke, strokeDasharray, strokeWidth } =\n      dataSet;\n\n    if (data?.length) {\n      const dataColorStroke = {\n        data: {}\n      };\n\n      if (fill && chartType !== 'line' && chartType !== 'threshold') {\n        dataColorStroke.data.fill = fill;\n      }\n\n      if (stroke) {\n        dataColorStroke.data.stroke = stroke;\n      }\n\n      if (strokeDasharray) {\n        dataColorStroke.data.strokeDasharray = strokeDasharray;\n      }\n\n      if (strokeWidth) {\n        dataColorStroke.data.strokeWidth = strokeWidth;\n      }\n\n      const defaultProps = {};\n\n      if (animate) {\n        defaultProps.animate = animate;\n      }\n\n      if (interpolation) {\n        defaultProps.interpolation = interpolation;\n      }\n\n      const chartElementProps = {\n        ...defaultProps,\n        key: `chart-${dataSet.id}-${chartType || ''}`,\n        name: `chart-${dataSet.id}-${chartType || ''}`,\n        data: dataSet.data,\n        style: { ...(dataSet.style || {}), ...dataColorStroke },\n        themeColor: dataSet.themeColor,\n        themeVariant: dataSet.themeVariant,\n        x:\n          (xValueFormat &&\n            (datum => {\n              const xValue = xValueFormat({ datum, maxX });\n              return xValue === undefined || Number.isNaN(xValue) ? 0 : xValue;\n            })) ||\n          undefined,\n        y: datum => {\n          let yValue;\n\n          if (yValueFormat) {\n            yValue = yValueFormat({\n              datum,\n              isMultiAxis: typeof maxY !== 'number',\n              maxY: typeof maxY === 'number' ? maxY : maxY?.[dataSet.id]\n            });\n          } else {\n            yValue = typeof maxY === 'number' ? datum.y : datum.y / maxY?.[dataSet.id]; // eslint-disable-line\n          }\n\n          return yValue === undefined || Number.isNaN(yValue) ? 0 : yValue;\n        }\n      };\n\n      const props = { ...chartElementProps };\n      const updatedProps = { chartType, props };\n\n      if (isStacked) {\n        stackedElementsById[id] = updatedProps;\n        stackedElements.push(updatedProps);\n      } else {\n        elementsById[id] = updatedProps;\n        elements.push(updatedProps);\n      }\n    }\n  });\n\n  return {\n    elements,\n    elementsById,\n    stackedElements,\n    stackedElementsById\n  };\n};\n\n/**\n * Preprocess datasets for tooltips.\n *\n * @param {object} params\n * @param {Node|Function} params.content\n * @param {Array} params.dataSets\n * @returns {{}}\n */\nconst generateTooltipData = ({ content = helpers.noop, dataSets = [] } = {}) => {\n  const tooltipDataSetLookUp = {};\n\n  if (content && Array.isArray(dataSets?.[0]?.data)) {\n    dataSets[0].data.forEach((dataSet, index) => {\n      const itemsByKey = {};\n\n      dataSets.forEach(data => {\n        if (data?.data[index]) {\n          itemsByKey[data.id] = {\n            color: data.stroke || data.fill || data.color || '',\n            chartType: data.chartType,\n            data: _cloneDeep(data.data[index])\n          };\n        }\n      });\n\n      const mockDatum = {\n        datum: { x: dataSet.x, y: dataSet.y, index, itemsByKey }\n      };\n\n      tooltipDataSetLookUp[dataSet.x] = {\n        x: dataSet.x,\n        y: null,\n        itemsByKey,\n        tooltip:\n          (React.isValidElement(content) && React.cloneElement(content, { ...mockDatum })) || content({ ...mockDatum })\n      };\n    });\n  }\n\n  return tooltipDataSetLookUp;\n};\n\n/**\n * Generate X axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {object} params.dataSet\n * @param {number} params.maxX\n * @param {number} params.xAxisLabelIncrement\n * @param {object} params.xAxisPropDefaults\n * @param {Function} params.xAxisTickFormat\n * @returns {{tickFormat: (function(*)), tickValues: *}}\n */\nconst generateXAxisProps = ({\n  dataSet = {},\n  maxX,\n  xAxisLabelIncrement,\n  xAxisPropDefaults = {},\n  xAxisTickFormat\n} = {}) => {\n  const { data = [], xAxisChartLabel } = dataSet;\n  const axisProps = {\n    ...xAxisPropDefaults,\n    tickValues: data.reduce(\n      (acc, current, index) => (index % xAxisLabelIncrement === 0 ? acc.concat(current.x) : acc),\n      []\n    ),\n    tickFormat: tick => data[tick]?.xAxisLabel || tick\n  };\n\n  if (typeof xAxisChartLabel === 'function') {\n    axisProps.label = xAxisChartLabel({ ...dataSet, xAxisChartLabel: undefined });\n  } else {\n    axisProps.label = xAxisChartLabel;\n  }\n\n  if (typeof xAxisTickFormat === 'function') {\n    axisProps.tickFormat = tick => {\n      const tickIndex = axisProps.tickValues.indexOf(tick);\n      const previousItem = { ...data[axisProps.tickValues[tickIndex - 1]] };\n      const nextItem = { ...data[axisProps.tickValues[tickIndex + 1]] };\n      const item = { ...data[tick] };\n\n      return xAxisTickFormat({ tick, previousItem, item, nextItem, maxX });\n    };\n  }\n\n  return axisProps;\n};\n\n/**\n * Generate Y axis props, ticks, tick formatting.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {number|object} params.maxY\n * @param {object} params.yAxisPropDefaults\n * @param {Function} params.yAxisTickFormat\n * @returns {Array}\n */\nconst generateYAxisProps = ({ dataSets = [], maxY, yAxisPropDefaults = {}, yAxisTickFormat } = {}) => {\n  const axisProps = [];\n  const isMultiAxis = dataSets.length > 1;\n\n  dataSets.forEach(({ yAxisChartLabel, id, stroke, strokeWidth, ...dataSet } = {}, index) => {\n    const updatedAxisProps = {\n      style: { axis: {}, tickLabels: {} },\n      tickFormat: tick => tick\n    };\n\n    if (isMultiAxis && stroke) {\n      updatedAxisProps.style.axis.stroke = stroke;\n    }\n\n    if (isMultiAxis && strokeWidth) {\n      updatedAxisProps.style.axis.strokeWidth = strokeWidth;\n    }\n\n    if (typeof yAxisChartLabel === 'function') {\n      updatedAxisProps.label = yAxisChartLabel({ id, stroke, strokeWidth, ...dataSet });\n    } else {\n      updatedAxisProps.label = yAxisChartLabel;\n    }\n\n    if (typeof yAxisTickFormat === 'function') {\n      const updatedMaxY = (typeof maxY === 'number' && maxY) || maxY?.[id];\n\n      updatedAxisProps.tickFormat = tick => {\n        const normalizedTick = (isMultiAxis && tick * updatedMaxY) || tick;\n\n        return yAxisTickFormat({\n          tick: normalizedTick,\n          isMultiAxis,\n          maxY: updatedMaxY\n        });\n      };\n    }\n\n    axisProps.push({\n      ...yAxisPropDefaults,\n      ...updatedAxisProps,\n      orientation: (index === 0 && 'left') || 'right'\n    });\n  });\n\n  return axisProps;\n};\n\n/**\n * Generate x,y props.\n *\n * @param {object} params\n * @param {Array} params.dataSets\n * @param {object} params.individualMaxY\n * @param {number} params.maxX\n * @param {number} params.maxY\n * @param {Node|Function} params.xAxisChartLabel\n * @param {Node|Function} params.yAxisChartLabel\n * @param {boolean} params.xAxisFixLabelOverlap\n * @param {number} params.xAxisLabelIncrement\n * @param {Function} params.xAxisTickFormat\n * @param {Function} params.yAxisTickFormat\n * @returns {{xAxisProps: object, yAxisProps: Array}}\n */\nconst generateAxisProps = ({\n  dataSets = [],\n  individualMaxY = {},\n  maxX,\n  maxY,\n  xAxisChartLabel,\n  yAxisChartLabel,\n  xAxisFixLabelOverlap = true,\n  xAxisLabelIncrement = 1,\n  xAxisTickFormat,\n  yAxisTickFormat\n} = {}) => {\n  const xAxisPropDefaults = {\n    fixLabelOverlap: xAxisFixLabelOverlap\n  };\n\n  const yAxisPropDefaults = {\n    dependentAxis: true,\n    showGrid: true\n  };\n\n  let yAxisDataSets = [];\n  let xAxisDataSet;\n\n  dataSets.forEach(dataSet => {\n    if (dataSet.yAxisUseDataSet) {\n      yAxisDataSets.push({\n        yAxisChartLabel,\n        ...dataSet\n      });\n    }\n    if (dataSet.xAxisUseDataSet) {\n      xAxisDataSet = {\n        xAxisChartLabel,\n        ...dataSet\n      };\n    }\n  });\n\n  if (!yAxisDataSets.length) {\n    yAxisDataSets.push({\n      yAxisChartLabel,\n      ...dataSets?.[0]\n    });\n  } else {\n    yAxisDataSets = yAxisDataSets.slice(0, 2);\n  }\n\n  if (!xAxisDataSet) {\n    xAxisDataSet = {\n      xAxisChartLabel,\n      ...dataSets?.[0]\n    };\n  }\n\n  const updatedMaxY = (yAxisDataSets.length > 1 && individualMaxY) || maxY;\n\n  return {\n    xAxisProps: generateXAxisProps({\n      dataSet: xAxisDataSet,\n      maxX,\n      xAxisLabelIncrement,\n      xAxisPropDefaults,\n      xAxisTickFormat\n    }),\n    yAxisProps: generateYAxisProps({ dataSets: yAxisDataSets, maxY: updatedMaxY, yAxisPropDefaults, yAxisTickFormat })\n  };\n};\n\nconst chartHelpers = {\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n\nexport {\n  chartHelpers as default,\n  chartHelpers,\n  generateAxisProps,\n  generateDomains,\n  generateElementsProps,\n  generateMaxXY,\n  generateTooltipData,\n  generateXAxisProps,\n  generateYAxisProps\n};\n","import React from 'react';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport { useChartContext, useToggleData } from './chartContext';\n\n/**\n * Wrapper for rendering an HTML based legend.\n *\n * @returns {Node}\n */\nconst ChartLegend = () => {\n  const { getIsToggled, onHide, onRevert, onToggle } = useToggleData();\n  const { chartSettings = {} } = useChartContext();\n  const { chartLegend, dataSets, padding = {}, xAxisProps = {} } = chartSettings;\n\n  if (!chartLegend) {\n    return null;\n  }\n\n  const legendProps = {\n    datum: { dataSets: _cloneDeep(dataSets) },\n    chart: {\n      hide: onHide,\n      revert: onRevert,\n      toggle: onToggle,\n      isToggled: getIsToggled\n    }\n  };\n\n  return (\n    <div\n      className={`curiosity-chartarea__legend${(xAxisProps?.label && '-axis-label-active') || ''}`}\n      style={{\n        marginLeft: (padding?.left && `${padding.left}px`) || 0,\n        marginRight: (padding?.right && `${padding.right}px`) || 0\n      }}\n    >\n      {(React.isValidElement(chartLegend) && React.cloneElement(chartLegend, { ...legendProps })) ||\n        chartLegend({ ...legendProps })}\n    </div>\n  );\n};\n\n/**\n * Prop types.\n */\nChartLegend.propTypes = {};\n\n/**\n * Default props.\n */\nChartLegend.defaultProps = {};\n\nexport { ChartLegend as default, ChartLegend };\n","import React from 'react';\nimport { helpers } from '../../common';\n\n/**\n * Note: Victory Charts components require a form of extended \"something\" applied by the consuming component.\n * This leads to odd implementations, like returning a function component.\n */\n/**\n * FixMe: The right graph boundary for tooltips is dependent on Voronoi container padding.\n * A limitation exists where Voronoi containers can only have a single padding setting. This means we use\n * the lowest number value from the \"padding\" setting. The repercussion is the right boundary either has to\n * be the lowest padding value, or equal to the lowest padding from any of the other dimensions, ie. top,\n * bottom, left.\n */\n/**\n * Return a compatible Victory tooltip component.\n *\n * @param {object} params\n * @param {object} params.chartSettings\n * @param {Function} params.chartContainerRef\n * @param {Function} params.chartTooltipRef\n * @param {number} params.minChartWidth\n * @returns {Function}\n */\nconst chartTooltip = ({\n  chartSettings = {},\n  chartContainerRef = helpers.noop,\n  chartTooltipRef = helpers.noop,\n  minChartWidth = 500\n} = {}) => {\n  // ToDo: evaluate using \"width\" in place of \"minWidth\" for scenarios where the graph size is smaller\n  /**\n   * Return a tooltip x coordinate.\n   *\n   * @param {object} params\n   * @param {number} params.x\n   * @param {number} params.width\n   * @param {number} params.tooltipWidth\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const getXCoordinate = ({ x, width, tooltipWidth, padding = 0, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth && x > tooltipWidth / 2 + padding && x < minWidth - tooltipWidth + padding) {\n      return x + padding - tooltipWidth / 2;\n    }\n\n    return x > width / 2 ? x - tooltipWidth + padding : x + padding;\n  };\n\n  /**\n   * Return a tooltip y coordinate.\n   *\n   * @param {object} params\n   * @param {number} params.y\n   * @param {number} params.height\n   * @param {number} params.tooltipHeight\n   * @param {number} params.width\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const getYCoordinate = ({ y, height, tooltipHeight, width, padding = 15, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth) {\n      return y > height / 2 ? y - tooltipHeight - padding : y + padding;\n    }\n\n    return height * 0.25;\n  };\n\n  // ToDo: evaluate using \"width\" in place of \"minWidth\" for scenarios where the graph size is smaller\n  /**\n   * Return a tooltip tail position CSS class.\n   *\n   * @param {object} params\n   * @param {number} params.x\n   * @param {number} params.width\n   * @param {number} params.tooltipWidth\n   * @param {number} params.padding\n   * @param {number} params.minWidth\n   * @returns {number}\n   */\n  const tailPosition = ({ x, width, tooltipWidth, padding = 0, minWidth = minChartWidth } = {}) => {\n    if (width <= minWidth && x > tooltipWidth / 2 + padding && x < minWidth - tooltipWidth + padding) {\n      return 'middle';\n    }\n\n    return x > width / 2 ? 'right' : 'left';\n  };\n\n  return ({ x, y, datum = {} }) => { // eslint-disable-line\n    const { padding = {}, tooltipDataSetLookUp = {} } = chartSettings;\n\n    const containerRef = chartContainerRef();\n    const tooltipRef = chartTooltipRef();\n    const updatedPadding = { bottom: 0, left: 0, right: 0, top: 0, ...padding };\n    const content = tooltipDataSetLookUp?.[datum.x]?.tooltip || '';\n    const containerBounds = containerRef?.current?.querySelector('svg')?.getBoundingClientRect() || {\n      width: 0,\n      height: 0\n    };\n\n    const tooltipBounds = tooltipRef?.current?.getBoundingClientRect() || { width: 0, height: 0 };\n\n    if (content) {\n      const isOutsideGraphBottom = y > containerBounds.height - updatedPadding.bottom;\n      const isOutsideGraphLeft = x < updatedPadding.left;\n      const isOutsideGraphRight = x > containerBounds.width - updatedPadding.right;\n      const isOutsideGraphTop = y < updatedPadding.top;\n      const updatedClassName = `${(tooltipBounds.height <= 0 && 'fadein') || ''}`;\n\n      return (\n        <g>\n          <foreignObject\n            x={getXCoordinate({ x, width: containerBounds.width, tooltipWidth: tooltipBounds.width })}\n            y={getYCoordinate({\n              y,\n              height: containerBounds.height,\n              tooltipHeight: tooltipBounds.height,\n              width: containerBounds.width\n            })}\n            width=\"100%\"\n            height=\"100%\"\n          >\n            <div\n              className={`curiosity-chartarea__tooltip-container ${updatedClassName}`}\n              ref={tooltipRef}\n              style={{\n                display:\n                  ((isOutsideGraphBottom || isOutsideGraphLeft || isOutsideGraphRight || isOutsideGraphTop) &&\n                    'none') ||\n                  'inline-block'\n              }}\n              xmlns=\"http://www.w3.org/1999/xhtml\"\n            >\n              <div\n                className={`curiosity-chartarea__tooltip curiosity-chartarea__tooltip-${tailPosition({\n                  x,\n                  y,\n                  width: containerBounds.width,\n                  tooltipWidth: tooltipBounds.width\n                })}`}\n              >\n                {content}\n              </div>\n            </div>\n          </foreignObject>\n        </g>\n      );\n    }\n\n    return <g />;\n  };\n};\n\nexport { chartTooltip as default, chartTooltip };\n"],"names":["Chart","chartLegend","chartTooltip","dataSets","padding","themeColor","xAxisChartLabel","yAxisChartLabel","xAxisFixLabelOverlap","xAxisLabelIncrement","xAxisTickFormat","yAxisTickFormat","xValueFormat","yValueFormat","useState","context","setContext","dataSetsToggle","setDataSetsToggle","containerRef","useRef","tooltipRef","chartWidth","target","width","height","dimensions","setDimensions","useEffect","isElementResize","window","ResizeObserver","element","current","removeObserver","helpers","handler","clientHeight","clientWidth","innerHeight","innerWidth","resizeObserver","observe","unobserve","addEventListener","removeEventListener","useResizeObserver","toggledDataSets","tooltipDataSetLookUp","maxX","maxY","individualMaxY","xAxisProps","yAxisProps","isMultiYAxis","chartElementsProps","domain","domainPadding","chartSettings","filter","id","chartHelpers","content","length","chartDomain","hasData","tickValues","bottom","left","right","top","updatedSettings","chartContainerRef","chartTooltipRef","ChartContext","value","className","ref","ChartElements","ChartLegend","defaultProps","chartAxisLabel","axis","index","x","y","text","style","xmlns","DEFAULT_CONTEXT","React","useChartContext","useContext","useToggleData","useAliasChartContext","contextDataSetsToggle","onHide","useCallback","prevState","onRevert","onToggle","updatedToggle","getIsToggled","chartElements","stackedChartElements","chartTypeDefaults","containerComponent","xAxis","yAxis","VictoryVoronoiCursorContainer","createContainer","TooltipLabelComponent","cursorDimension","voronoiDimension","labels","obj","labelComponent","dx","dy","centerOffset","flyoutStyle","fill","stroke","voronoiPadding","Object","values","sort","mouseFollowTooltips","keys","updatedXAxisProps","label","AxisLabelComponent","axisLabelComponent","C","animate","Array","isArray","map","axisProps","updatedAxisProps","key","orientation","setChartElement","chartType","props","area","Component","component","elements","stackedElements","duration","ChartArea","onLoad","interpolation","line","ChartLine","threshold","ChartThreshold","generateMaxXY","individualDataSetsMaxY","combinedDataSetMaxX","combinedDataSetsMaxY","isStacked","forEach","data","Math","max","dataSetMaxY","generateDomains","updatedChartDomain","updatedPadding","generatedDomain","floored","pow","floor","log10","ceil","toString","generateElementsProps","elementsById","stackedElementsById","dataSet","strokeDasharray","strokeWidth","dataColorStroke","chartElementProps","name","themeVariant","datum","xValue","undefined","Number","isNaN","yValue","isMultiAxis","updatedProps","push","generateTooltipData","itemsByKey","color","_cloneDeep","mockDatum","tooltip","generateXAxisProps","xAxisPropDefaults","reduce","acc","concat","tickFormat","tick","xAxisLabel","tickIndex","indexOf","previousItem","nextItem","item","generateYAxisProps","yAxisPropDefaults","tickLabels","updatedMaxY","generateAxisProps","xAxisDataSet","fixLabelOverlap","dependentAxis","showGrid","yAxisDataSets","yAxisUseDataSet","xAxisUseDataSet","slice","legendProps","chart","hide","revert","toggle","isToggled","marginLeft","marginRight","minChartWidth","getXCoordinate","tooltipWidth","minWidth","getYCoordinate","tooltipHeight","tailPosition","containerBounds","querySelector","getBoundingClientRect","tooltipBounds","isOutsideGraphBottom","isOutsideGraphLeft","isOutsideGraphRight","isOutsideGraphTop","updatedClassName","display"],"sourceRoot":""}